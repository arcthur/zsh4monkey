#!/usr/bin/env zsh

local direnv cache=$Z4M/cache/direnv
if [[ -e $cache ]]; then
  builtin source -- $cache || return
  [[ -n $direnv ]] || return '_z4m_err()'
fi

if (( $1 )); then
  local real_direnv=${commands[direnv]-}
  if [[ $direnv != $real_direnv ]]; then
    if [[ -n $real_direnv ]]; then
      direnv=$real_direnv
      if (( ! _z4m_dangerous_root )); then
        local tmp=$cache.tmp.$$
        typeset -p direnv >$tmp || return
        zf_mv -f -- $tmp $cache || return
      fi
    else
      [[ ! -e $cache ]] || builtin : >$cache || return
      return
    fi
  elif [[ -z $direnv ]]; then
    return
  fi
elif [[ ! -x $direnv ]]; then
  return
fi

# Run direnv hook but don't fail initialization if it times out or is interrupted
# This prevents direnv issues from triggering recovery mode
-z4m-direnv-hook $direnv || {
  # Only propagate real errors, not timeouts/interrupts
  local -i ret=$?
  if [[ ${_z4m_direnv_sig-} == (timeout|interrupted) ]]; then
    # Direnv was interrupted or timed out, but initialization should continue
    true
  else
    return $ret
  fi
}

typeset -gi _z4m_direnv_initialized=1
