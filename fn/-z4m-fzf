#!/usr/bin/env zsh

emulate -L zsh -o typeset_silent -o pipe_fail -o extended_glob \
    -o prompt_percent -o no_prompt_subst -o no_prompt_bang -o no_bg_nice -o no_aliases

local -a _z4m_env=()
# Clear FZF_DEFAULT_OPTS for the fzf process only (avoid mutating current shell state).
# See: https://github.com/Aloxaf/fzf-tab/issues/461
if command env -u FZF_DEFAULT_OPTS true >/dev/null 2>&1; then
  _z4m_env=(command env -u FZF_DEFAULT_OPTS)
else
  # Fallback for env implementations without -u.
  _z4m_env=(FZF_DEFAULT_OPTS=)
fi

local widget=${WIDGET#z4m-}

# Detect fzf version for feature gating
autoload +X -Uz -- -z4m-fzf-version -z4m-fzf-theme
-z4m-fzf-version 2>/dev/null || true
local -i ver=${_z4m_fzf_version_num:-0}

local -a cmd flags bindings
zstyle -a :z4m:$widget fzf-command cmd || cmd=(fzf)
zstyle -a :z4m:$widget fzf-flags flags || flags=()
zstyle -a :z4m:$widget fzf-bindings bindings || bindings=()

# Treat `--expect` as an API owned by z4m. If users inject it via `fzf-flags`,
# we absorb it here and pass a single merged `--expect` to fzf.
local -a _z4m_flags=()
local -a _z4m_flags_expect_keys=()
local -i _z4m_i=1
while (( _z4m_i <= $#flags )); do
  local _z4m_f=${flags[_z4m_i]}
  if [[ $_z4m_f == --expect=* ]]; then
    local _z4m_raw=${_z4m_f#--expect=}
    [[ -n $_z4m_raw ]] && _z4m_flags_expect_keys+=(${(s:,:)${_z4m_raw}})
    (( _z4m_i++ ))
    continue
  fi
  if [[ $_z4m_f == --expect ]]; then
    local _z4m_raw=${flags[_z4m_i+1]:-}
    [[ -n $_z4m_raw ]] && _z4m_flags_expect_keys+=(${(s:,:)${_z4m_raw}})
    (( _z4m_i += 2 ))
    continue
  fi
  _z4m_flags+=("$_z4m_f")
  (( _z4m_i++ ))
done
flags=("${_z4m_flags[@]}")

# Apply theme colors
local -a reply=()
-z4m-fzf-theme $widget
flags+=("${reply[@]}")

# Tmux popup support (fzf 0.54+)
if (( ver >= 5400 )) && [[ -n $TMUX ]]; then
  local tmux_mode
  zstyle -s ":z4m:$widget" fzf-tmux tmux_mode ||
  zstyle -s ':z4m:*' fzf-tmux tmux_mode
  if [[ -n $tmux_mode && $tmux_mode != no ]]; then
    case $tmux_mode in
      yes|popup|center) flags+=(--tmux=center,80%,60%) ;;
      top)              flags+=(--tmux=top,100%,50%) ;;
      bottom)           flags+=(--tmux=bottom,100%,50%) ;;
      left)             flags+=(--tmux=left,50%,100%) ;;
      right)            flags+=(--tmux=right,50%,100%) ;;
      *)                flags+=(--tmux=$tmux_mode) ;;
    esac
  fi
fi

# Highlight line support (fzf 0.52+)
if (( ver >= 5200 )); then
  zstyle -T ":z4m:$widget" fzf-highlight-line && flags+=(--highlight-line)
fi

# Wrap support (fzf 0.56+)
if (( ver >= 5600 )); then
  zstyle -T ":z4m:$widget" fzf-wrap && flags+=(--wrap)
fi

# Pointer and marker customization (fzf 0.54+)
if (( ver >= 5400 )); then
  local pointer marker
  zstyle -s ":z4m:$widget" fzf-pointer pointer ||
  zstyle -s ':z4m:*' fzf-pointer pointer
  zstyle -s ":z4m:$widget" fzf-marker marker ||
  zstyle -s ':z4m:*' fzf-marker marker
  [[ -n $pointer ]] && flags+=(--pointer=$pointer)
  [[ -n $marker ]] && flags+=(--marker=$marker)
fi

local -A keys=(
  ctrl-h     backward-kill-word
  alt-j      clear-query
  ctrl-u     clear-query
  ctrl-k     kill-line
  alt-k      unix-line-discard
  ctrl-space toggle-out
  ctrl-a     toggle-all
)

# Advanced bindings (fzf 0.45+): preview toggle
if (( ver >= 4500 )); then
  keys+=(
    ctrl-/   toggle-preview
    alt-p    toggle-preview
  )
fi

# Track current item (fzf 0.49+)
if (( ver >= 4900 )); then
  keys+=(alt-t track-current)
fi

if (( ${@[(I)--layout=default]} )); then
  keys+=(
    tab      up
    btab     down
    ctrl-r   up
    ctrl-s   down
  )
else
  keys+=(
    tab      down
    btab     up
    ctrl-r   down
    ctrl-s   up
  )
fi

# Preview scroll bindings (if preview is enabled)
if (( ${@[(I)--preview=*]} || ${@[(I)--preview-window=*]} )); then
  keys+=(
    ctrl-f   preview-page-down
    ctrl-b   preview-page-up
    alt-up   preview-up
    alt-down preview-down
  )
fi

local kv
for kv in $bindings; do
  kv=(${(s.:.)kv})
  (( $#kv == 2 )) || continue
  keys[$kv[1]]=$kv[2]
done

local k v
local -a _z4m_expect_keys=(enter)
_z4m_expect_keys+=("${_z4m_flags_expect_keys[@]}")
local -a _z4m_repeat_expect_keys=()
for k v in ${(kv)keys}; do
  if [[ +$v+ == *+repeat+* ]]; then
    _z4m_repeat_expect_keys+=($k)
    if [[ $v == repeat(|+*) ]]; then
      keys[$k]=ignore
    else
      keys[$k]=${v%%+repeat(|+*)}
    fi
  fi
done

# Merge caller-provided --expect keys with z4m's own expectations.
# We always include `enter` to get a stable first-line "key" record.
local -a _z4m_argv=()
local _z4m_arg
local -i _z4m_ai=1
while (( _z4m_ai <= $# )); do
  _z4m_arg=${@[_z4m_ai]}
  if [[ $_z4m_arg == --expect=* ]]; then
    local _z4m_raw=${_z4m_arg#--expect=}
    [[ -n $_z4m_raw ]] && _z4m_expect_keys+=(${(s:,:)${_z4m_raw}})
    (( _z4m_ai++ ))
    continue
  fi
  if [[ $_z4m_arg == --expect ]]; then
    local _z4m_raw=${@[_z4m_ai+1]:-}
    [[ -n $_z4m_raw ]] && _z4m_expect_keys+=(${(s:,:)${_z4m_raw}})
    (( _z4m_ai += 2 ))
    continue
  fi
  _z4m_argv+=("$_z4m_arg")
  (( _z4m_ai++ ))
done
_z4m_expect_keys+=("${_z4m_repeat_expect_keys[@]}")

local -A _z4m_expect_seen=()
local -a _z4m_expect_uniq=()
for _z4m_arg in "${_z4m_expect_keys[@]}"; do
  [[ -n $_z4m_arg ]] || continue
  (( ${+_z4m_expect_seen[$_z4m_arg]} )) && continue
  _z4m_expect_seen[$_z4m_arg]=1
  _z4m_expect_uniq+=("$_z4m_arg")
done

_z4m_argv+=(--expect=${(j:,:)${_z4m_expect_uniq}})

local keymap
printf -v keymap '%s:%s,' ${(kv)keys}
local out=$(${_z4m_env[@]} "${cmd[@]}" "${_z4m_argv[@]}" --bind=${keymap%,} "${flags[@]}")

[[ -n $out ]] || return

# Normalize Enter key to an empty first line for backward-compatible parsing.
out=${out/#enter$'\n'/$'\n'}

print -r -- "$out"
