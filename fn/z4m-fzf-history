#!/usr/bin/env zsh

# fzf-history-widget with duplicate removal, preview and syntax highlighting (requires `bat`).
#
# Disable preview:
#
#   zstyle :z4m:fzf-history fzf-flags --no-preview

emulate -L zsh -o typeset_silent -o pipe_fail -o extended_glob \
    -o prompt_percent -o no_prompt_subst -o no_prompt_bang -o no_bg_nice -o no_aliases

[[ -v _z4m_tty_fd ]] || return

# Detect fzf version for --scheme support
autoload +X -Uz -- -z4m-fzf-version
-z4m-fzf-version 2>/dev/null || true
local -i ver=${_z4m_fzf_version_num:-0}

# Build preview command with enhanced formatting
local preview='printf "%s" {} | command cut -f2- -d'$'\1'
if (( $+commands[bat] )); then
  # Use bat with bash syntax highlighting
  preview+=' | command bat -l bash --color always -pp --wrap=character --terminal-width=$((FZF_PREVIEW_COLUMNS-1))'
elif (( $+commands[highlight] )); then
  # Fallback to highlight if available
  preview+=' | command highlight -O ansi -S bash'
fi

{
  -z4m-show-dots ''

  autoload +X -Uz -- -z4m-cursor-show

  local cursor_y cursor_x
  -z4m-get-cursor-pos || return

  local query=${(j: :)${(@Z:cn:)BUFFER}}
  [[ -n $query ]] && query+=' '

  if (( _z4m_can_save_restore_screen )) && zstyle -T :z4m:fzf-history fzf-preview; then
    local opts=(
      --read0
      --no-multi
      --no-sort
      --cycle
      --exact
      --no-mouse
      --tabstop 1
      --query=$query
      --no-clear
      --layout=default
      --preview-window=wrap:4:down:noborder
      --preview=$preview
      --height=$LINES
    )
    # Use history-optimized scoring (fzf 0.59+)
    (( ver >= 5900 )) && opts+=(--scheme=history)
    local move=$'\e[0m\e[H'
    local _z4m_saved_screen
    -z4m-save-screen || return
  else
    # A big chunk of this branch is dead code because _z4m_can_save_restore_screen is false.
    # I'm keeping it for a while in case I decide to change this logic.
    local -i pct=80
    (( _z4m_can_save_restore_screen )) && pct=100

    local -i space
    if (( _z4m_can_save_restore_screen )); then
      (( space = LINES - cursor_y < cursor_y - 1 ? cursor_y - 1 : LINES - cursor_y ))
    else
      (( space = LINES - 1 ))
    fi
    (( space <= pct * LINES / 100 )) || (( space = pct * LINES / 100 ))

    local opts=(
      --read0
      --no-multi
      --no-sort
      --cycle
      --exact
      --no-mouse
      --tabstop 1
      --query=$query
    )
    # Use history-optimized scoring (fzf 0.59+)
    (( ver >= 5900 )) && opts+=(--scheme=history)

    local -i preview_lines=6
    local -i height=$(($#history + 2))
    (( height >= 4 )) || (( height = 4 ))
    local preview_window=wrap:$preview_lines
    if (( height + preview_lines <= space || space > preview_lines + 5 )) &&
       zstyle -T :z4m:fzf-history fzf-preview; then
      (( height += preview_lines ))
    else
      preview_lines=0
    fi

    (( height <= pct * LINES / 100 )) || (( height = pct * LINES / 100 ))
    (( height <= LINES - 1 )) || (( height = LINES - 1 ))

    if (( _z4m_can_save_restore_screen )); then
      opts+=(--no-clear)
      if { (( height <= cursor_y - 1 )) && zstyle -T :z4m: prompt-at-bottom } ||
        (( cursor_y - 1 > LINES - cursor_y && cursor_y - 1 > 5 + preview_lines )) &&
        { (( height > LINES - cursor_y )) || zstyle -T :z4m: prompt-at-bottom }; then
        preview_window+=':up'
        (( preview_lines )) || opts+=(--border=horizontal)
        (( height <= cursor_y - 1 )) || (( height = cursor_y - 1 ))
        local move=$'\e[0m\e['$((cursor_y-height))';1H'
        opts+=(--layout=default)
      elif (( LINES - cursor_y > 5 + preview_lines )); then
        preview_window+=':down'
        (( height <= LINES - cursor_y )) || (( height = LINES - cursor_y ))
        local move=$'\e[0m\n\r'
        opts+=(--layout=reverse)
      else
        preview_window+=':down'
        local -i extra=$((height - LINES + cursor_y))
        print -rnu $_z4m_tty_fd -- ${(pl:$height::\n:)} || return
        (( cursor_y += LINES - cursor_y - height ))
        local move=$'\e[0m\e['$((cursor_y+1))';1H'
        opts+=(--layout=reverse)
      fi
      local _z4m_saved_screen
      -z4m-save-screen || return
    else
      print -u $_z4m_tty_fd || return
      preview_window+=':down'
      local move=
      opts+=(--layout=reverse)
    fi

    opts+=(--height=$height)
    if (( preview_lines )); then
      opts+=(
        --preview-window=$preview_window
        --preview=$preview
      )
    fi
  fi

  {
    local choice
    choice=$(
      unsetopt pipe_fail
      {
        # This `noglob` is a workaround for a bug in zsh that can be
        # triggered by certain corrupted history files.
        #
        # https://github.com/romkatv/zsh4monkey/issues/313
        (( $#history )) && noglob printf '%s\000' "${history[@]}"
      } | {
        {
          print -rnu $_z4m_tty_fd -- $move
          -z4m-cursor-show
          2>&$_z4m_tty_fd -z4m-fzf $opts
        } always {
          -z4m-cursor-hide
        }
      })
    [[ -n $choice ]] || return
    BUFFER=${choice#*$'\n'}
    typeset -gi CURSOR='_z4m_cursor_max()'
    if (( _z4m_use[zsh-autosuggestions] )); then
      typeset -g _z4m_autosuggest_buffer=$BUFFER
      unset _z4m_autosuggestion POSTDISPLAY
    fi
    if (( _z4m_use[zsh-autosuggestions] || _z4m_use[fast-syntax-highlighting] )); then
      -z4m-redraw-buffer
    fi
    return 0
  } always {
    if (( _z4m_can_save_restore_screen )); then
      -z4m-restore-screen
      print -rn -- $'\e[0m\e['$cursor_y';'$cursor_x'H'
    else
      builtin echoti cuu 1
      (( cursor_x > 1 )) && builtin echoti cuf $((cursor_x-1))
    fi
  }
} always {
  zle -R
  -z4m-cursor-show
}
