#!/usr/bin/env zsh
#
# z4m ssh - SSH with zsh4monkey teleportation
#
# Usage:
#   z4m ssh [--force-sync] [ssh-options] [user@]hostname
#
# See configuration.md for full zstyle documentation:
#   - :z4m:ssh:HOST enable, send-extra-files, retrieve-extra-files
#   - :z4m:ssh:HOST ssh-command, retrieve-history, term, sync-mode
#   - :z4m:ssh:HOST configure (custom setup function)

emulate -L zsh -o typeset_silent -o pipe_fail -o extended_glob \
    -o prompt_percent -o no_prompt_subst -o no_prompt_bang -o no_bg_nice -o no_aliases
-z4m-check-core-params || return

if (( _z4m_dangerous_root )); then
  print -Pru2 -- "%F{3}z4m%f: refusing to %Bssh%b as %F{1}root%f"
  return 1
fi

local -i must_passthrough i force_sync=0
local -a pos args_to_remove
i=1
while (( i <= $# )); do
  case $*[i] in
    --force-sync)
      force_sync=1
      args_to_remove+=($i)
      ((++i))
      ;;
    --)
      ((++i))
      (( i <= $# )) && pos+=({$i..$#})
      break
      ;;
    -[OG])
      # Options that trigger passthrough, with argument
      must_passthrough=1
      ((i+=2))
      ;;
    -[bcDEeFIiJLlmOopQRSWw])
      # Options that take an argument (including -J for ProxyJump)
      ((i+=2))
      ;;
    -*)
      # Options without argument
      ((++i))
      ;;
    *)
      # Positional argument (hostname)
      pos+=($i)
      ((++i))
      ;;
  esac
done
# Remove --force-sync from arguments
for i in ${(On)args_to_remove}; do
  set -- "${@[1,i-1]}" "${@[i+1,-1]}"
done

local z4m_min_version
z4m_min_version=${$(<$Z4M/zsh4monkey/version)%$'\r'} || return
if [[ $z4m_min_version != <1-> ]]; then
  print -Pru2 -- '%F{3}z4m%f: invalid file content: %F{1}%U$Z4M/zsh4monkey/version%f%u'
  return 1
fi
local -r z4m_min_version

local -r z4m_ssh_client=${${(%):-%m}:-unknown}

# Parse ~/.ssh/config for ProxyJump (used for informational purposes)
-z4m-ssh-get-proxy-jump() {
  local target=$1
  local config=${SSH_CONFIG:-$HOME/.ssh/config}
  [[ -r $config ]] || return 1

  local in_host=0 proxy_jump= keyword
  while IFS= read -r line || [[ -n $line ]]; do
    line=${line%%#*}
    [[ -z ${line// } ]] && continue
    keyword=${line%%[[:space:]]*}
    case ${(L)keyword} in
      host)
        in_host=0
        local pattern
        for pattern in ${(z)line#[Hh][Oo][Ss][Tt] }; do
          [[ $target == $~pattern ]] && { in_host=1; break; }
        done
        ;;
      proxyjump|proxycommand)
        (( in_host )) && { proxy_jump=${line#*[[:space:]]}; break; }
        ;;
    esac
  done < $config
  [[ -n $proxy_jump ]] && print -r -- $proxy_jump
}

# Extract target hostname from positional arguments
# Use last positional arg (after -J jumphost, the target is last)
local z4m_ssh_host
if (( $#pos >= 1 )); then
  local user_host=$*[pos[-1]]
  z4m_ssh_host=${${user_host##*@}%%:*}
fi
local -r z4m_ssh_host

[[ -n $z4m_ssh_host ]] || must_passthrough=1

local -i z4m_ssh_enable=$(( !must_passthrough ))
zstyle -t :z4m:ssh:$z4m_ssh_host enable || z4m_ssh_enable=0

local -i mkdir_control_master=0
local default_ssh_command=(command ssh)
if (( z4m_ssh_enable )); then
  mkdir_control_master=1
  default_ssh_command+=(
    -o ControlMaster=auto
    -o ControlPersist=5
    -o ControlPath='~/.ssh/s/%C')
fi

local -a z4m_ssh_command
if ! zstyle -a :z4m:ssh:$z4m_ssh_host ssh-command z4m_ssh_command; then
  z4m_ssh_command=($default_ssh_command)
fi

local term
zstyle -s :z4m:ssh:$z4m_ssh_host term term || term=${TERM:/tmux-256color/screen-256color}

local -A z4m_ssh_send_files z4m_ssh_retrieve_files
local -a z4m_ssh_prelude z4m_ssh_setup z4m_ssh_run z4m_ssh_teardown
local -aU z4m_retrieve_history

if (( !must_passthrough )); then
  z4m_ssh_prelude=(
    '"export" ZDOTDIR="$HOME"'
    'if command -v "locale" >"/dev/null" 2>&1; then
      "export" LC_ALL="C"
    fi')

  z4m_ssh_send_files=(
    $ZDOTDIR/.zshenv   '"$ZDOTDIR"/.zshenv'
    $ZDOTDIR/.zprofile '"$ZDOTDIR"/.zprofile'
    $ZDOTDIR/.zshrc    '"$ZDOTDIR"/.zshrc'
    $ZDOTDIR/.zlogin   '"$ZDOTDIR"/.zlogin'
    $ZDOTDIR/.zlogout  '"$ZDOTDIR"/.zlogout')

  local file
  for file in $ZDOTDIR/.p10k{,-ascii}{,-8color}.zsh(N) $ZDOTDIR/.zsh_history.*:$z4m_ssh_host(N); do
    z4m_ssh_send_files[$file]='"$ZDOTDIR"/'${(q)file:t}
  done

  local -a extra_files
  if zstyle -a :z4m:ssh:$z4m_ssh_host send-extra-files extra_files; then
    local src dst
    for dst in $extra_files; do
      eval "src=$dst"
      z4m_ssh_send_files[$src]=$dst
    done
  fi

  z4m_ssh_run=(
    'if "[" "-f" "$ZDOTDIR"/.zshenv "-a" "-r" "$ZDOTDIR"/.zshenv "]"; then
      "." "$ZDOTDIR"/.zshenv
    else
      >&2 "printf" "\\033[33mz4m\\033[0m: not a readable file: \\033[31m%s\033[0m\n" "$ZDOTDIR"/.zshenv
      "false"
    fi')

  if zstyle -a :z4m:ssh:$z4m_ssh_host retrieve-extra-files extra_files; then
    local src dst
    for src in $extra_files; do
      eval "dst=$src"
      z4m_ssh_retrieve_files[$src]=$dst
    done
  fi

  zstyle -a :z4m:ssh:$z4m_ssh_host retrieve-history z4m_retrieve_history || z4m_retrieve_history=()

  # Environment variable propagation
  local -a propagate_env propagate_patterns propagate_exclude
  zstyle -a :z4m:ssh:$z4m_ssh_host propagate-env propagate_env
  zstyle -a :z4m:ssh:$z4m_ssh_host propagate-env-patterns propagate_patterns
  zstyle -a :z4m:ssh:$z4m_ssh_host propagate-env-exclude propagate_exclude

  if (( $#propagate_env || $#propagate_patterns )); then
    # Default exclusions for security
    local -a default_exclude=(
      '*_SECRET' '*_SECRET_*' '*SECRET_*'
      '*_TOKEN' '*_TOKEN_*' '*TOKEN_*'
      '*_KEY' '*_API_KEY' '*API_KEY*'
      '*_PASSWORD' '*PASSWORD*'
      '*_CREDENTIAL*' '*CREDENTIAL*'
      'AWS_SECRET_*' 'AWS_SESSION_TOKEN'
      'GITHUB_TOKEN' 'GH_TOKEN' 'GITLAB_TOKEN'
      'NPM_TOKEN' 'NPM_AUTH_TOKEN'
      'DOCKER_PASSWORD' 'DOCKER_AUTH_*'
    )
    propagate_exclude+=($default_exclude)

    local -a env_to_propagate=()
    local var pattern

    # Directly specified variables
    for var in $propagate_env; do
      [[ -v $var ]] && env_to_propagate+=($var)
    done

    # Pattern matching
    if (( $#propagate_patterns )); then
      for var in ${(k)parameters}; do
        # Skip special/internal variables
        [[ $var == _* || $var == Z4M_* || $var == z4m_* ]] && continue
        for pattern in $propagate_patterns; do
          if [[ $var == $~pattern ]]; then
            env_to_propagate+=($var)
            break
          fi
        done
      done
    fi

    # Apply exclusions
    if (( $#propagate_exclude )); then
      local -a filtered=()
      for var in $env_to_propagate; do
        local excluded=0
        for pattern in $propagate_exclude; do
          if [[ $var == $~pattern ]]; then
            excluded=1
            break
          fi
        done
        (( excluded )) || filtered+=($var)
      done
      env_to_propagate=($filtered)
    fi

    # Deduplicate
    env_to_propagate=(${(u)env_to_propagate})

    if (( $#env_to_propagate )); then
      # Data-only payload (no shell code). Each line is tab-separated.
      #   header: Z4M_ENV
      #   scalar: NAME\tS\t<val_b64>
      #   array:  NAME\tA\t<count>\t<elem1_b64>\t...\t<elemN_b64>
      #   assoc:  NAME\tM\t<count>\t<k1_b64>\t<v1_b64>\t...\t<kN_b64>\t<vN_b64>
      # The whole payload is then base64-encoded and assigned to _Z4M_PROPAGATED_ENV_B64.

      local -A _z4m_limits
      -z4m-env-propagation-limits _z4m_limits || return 1
      local -ir _z4m_max_vars=${_z4m_limits[max_vars]}
      local -ir _z4m_max_scalar=${_z4m_limits[max_scalar]}
      local -ir _z4m_max_elems=${_z4m_limits[max_elems]}
      local -ir _z4m_max_key=${_z4m_limits[max_key]}
      local -ir _z4m_max_value=${_z4m_limits[max_value]}
      local -ir _z4m_max_payload=${_z4m_limits[max_payload]}

      local -a env_lines
      env_lines=(Z4M_ENV)

      function _z4m_b64enc() {
        print -rn -- "$1" | command base64 2>/dev/null | command tr -d '\n'
      }

      local -i _z4m_vars=0
      for var in $env_to_propagate; do
        [[ $var == [A-Za-z_][A-Za-z0-9_]## ]] || continue
        [[ $var != (_Z4M_*|Z4M_*|_z4m_*|z4m_*) ]] || continue
        (( ++_z4m_vars <= _z4m_max_vars )) || break

        local vtype=${(Pt)var}
        case $vtype in
          scalar*)
            local val=${(P)var}
            (( ${#val} > _z4m_max_scalar )) && continue
            local val_b64
            val_b64=$(_z4m_b64enc "$val") || continue
            [[ -n $val_b64 ]] || continue
            env_lines+=("$var"$'\t'"S"$'\t'"$val_b64")
            ;;
          array*)
            typeset -n _z4m_ref=$var
            local -a _z4m_vals
            _z4m_vals=("${_z4m_ref[@]}")
            (( ${#_z4m_vals} <= _z4m_max_elems )) || continue
            local -a _z4m_fields
            _z4m_fields=($var A ${#_z4m_vals})
            local _z4m_elem _z4m_elem_b64
            for _z4m_elem in "${_z4m_vals[@]}"; do
              (( ${#_z4m_elem} <= _z4m_max_value )) || { _z4m_fields=(); break }
              _z4m_elem_b64=$(_z4m_b64enc "$_z4m_elem") || { _z4m_fields=(); break }
              [[ -n $_z4m_elem_b64 ]] || { _z4m_fields=(); break }
              _z4m_fields+=("$_z4m_elem_b64")
            done
            (( ${#_z4m_fields} )) || continue
            env_lines+=("${(j:\t:)_z4m_fields}")
            ;;
          association*)
            typeset -n _z4m_ref=$var
            local -a _z4m_kv
            _z4m_kv=("${(@kv)_z4m_ref}")
            local -i _z4m_pairs=$(( ${#_z4m_kv} / 2 ))
            (( _z4m_pairs <= _z4m_max_elems )) || continue
            local -a _z4m_fields
            _z4m_fields=($var M $_z4m_pairs)
            local _z4m_k _z4m_v _z4m_k_b64 _z4m_v_b64
            local -i _z4m_i=1
            while (( _z4m_i <= ${#_z4m_kv} )); do
              _z4m_k=$_z4m_kv[_z4m_i]
              _z4m_v=$_z4m_kv[_z4m_i+1]
              (( ${#_z4m_k} <= _z4m_max_key && ${#_z4m_v} <= _z4m_max_value )) || { _z4m_fields=(); break }
              _z4m_k_b64=$(_z4m_b64enc "$_z4m_k") || { _z4m_fields=(); break }
              _z4m_v_b64=$(_z4m_b64enc "$_z4m_v") || { _z4m_fields=(); break }
              [[ -n $_z4m_k_b64 && -n $_z4m_v_b64 ]] || { _z4m_fields=(); break }
              _z4m_fields+=("$_z4m_k_b64" "$_z4m_v_b64")
              _z4m_i+=2
            done
            (( ${#_z4m_fields} )) || continue
            env_lines+=("${(j:\t:)_z4m_fields}")
            ;;
        esac
      done

      if (( ${#env_lines} > 1 )); then
        local payload=${(F)env_lines}
        if (( ${#payload} <= _z4m_max_payload )); then
          local encoded
          encoded=$(print -rn -- "$payload" | command base64 2>/dev/null | command tr -d '\n') || true
          if [[ -n $encoded ]]; then
            z4m_ssh_prelude+=(
              "export _Z4M_PROPAGATED_ENV_B64='$encoded'"
            )
          fi
        fi
      fi
    fi
  fi
fi

local configure
if zstyle -s :z4m:ssh:$z4m_ssh_host configure configure; then
  eval $configure || return
elif (( $+functions[z4m-ssh-configure] )); then
  z4m-ssh-configure || return
fi

if (( ! $#z4m_ssh_command )); then
  print -Pru2 -- '%F{3}z4m%f: empty %F{1}z4m_ssh_command%f'
  return 1
fi

if [[ $mkdir_control_master == 1 &&
      ${(pj:\0:)z4m_ssh_command} == ${(pj:\0:)default_ssh_command} &&
      ! -d ~/.ssh/s && -n ~(#qNU) ]]; then
  zf_mkdir -pm 700 ~/.ssh/s || return
  {
    >~/.ssh/s/README <<\END
This directory has been created by `z4m ssh`. It stores control sockets
for SSH connections. See ControlMaster, ControlPath and ControlPersist
in `man ssh_config`. This directory must not be writable by anyone other
than the current user.
END
  } || return
  if [[ -e ~/.ssh/control-master/README ]]; then
    {
      >>~/.ssh/s/README <<\END

You might also have ~/.ssh/control-master with the same file in it. This
is the old directory that was used by zsh4monkey for the same purpose
before 2021-11-14. If you don't reference that directory explicitly from
~/.ssh/config, you can safely delete it.
END
    } || return
  fi
fi

if (( must_passthrough || !z4m_ssh_enable )); then
  TERM=${term:-$TERM} "${z4m_ssh_command[@]}" "$@"
  return
fi

# Incremental sync configuration
local sync_mode
zstyle -s :z4m:ssh:$z4m_ssh_host sync-mode sync_mode || sync_mode='smart'
case $sync_mode in
  full|incremental|smart) ;;
  *) sync_mode='smart' ;;
esac

# Offline mode configuration
local -i offline_mode=0
zstyle -t :z4m:ssh:$z4m_ssh_host offline-mode && offline_mode=1
local sync_state_dir=$Z4M/ssh-sync-state
local sync_state_file=$sync_state_dir/${z4m_ssh_host//\//_}.state

if (( $#z4m_retrieve_history )); then
  local local_hist_tmp=$Z4M/tmp/ssh-history.tmp.$sysparams[pid]
  z4m_ssh_retrieve_files[\$HISTFILE]=$local_hist_tmp
  zf_rm -f -- $local_hist_tmp || return
else
  local local_hist_tmp=
fi

local file
for file in "${(@kv)z4m_ssh_send_files}"; do
  if [[ -z $file ]]; then
    print -Pru2 -- '%F{3}z4m%f: empty element(s) in %F{1}z4m_ssh_send_files%f'
    return 1
  fi
  if [[ $file == */ ]]; then
    print -Pru2 -- "%F{3}z4m%f: element(s) of %Bz4m_ssh_send_files%b end with %B/%b: %F{1}${file//\%/%%}%f"
    return 1
  fi
done
for file in "${(@kv)z4m_ssh_retrieve_files}"; do
  if [[ -z $file ]]; then
    print -Pru2 -- '%F{3}z4m%f: empty element(s) in %F{1}z4m_ssh_retrieve_files%f'
    return 1
  fi
  if [[ $file == */ ]]; then
    print -Pru2 -- "%F{3}z4m%f: element(s) of %Bz4m_ssh_retrieve_files%b end with %B/%b: %F{1}${file//\%/%%}%f"
    return 1
  fi
done
for file in "${(@)z4m_retrieve_history}"; do
  if [[ -z $file ]]; then
    print -Pru2 -- '%F{3}z4m%f: empty element(s) in %F{1}z4m_retrieve_history%f'
    return 1
  fi
  if [[ $file == */ ]]; then
    print -Pru2 -- "%F{3}z4m%f: element(s) of %Bz4m_retrieve_history%b end with %B/%b: %F{1}${file//\%/%%}%f"
    return 1
  fi
  if [[ -e $file ]]; then
    if [[ ! ( -f $file && -r $file && -w $file ) ]]; then
      print -Pru2 -- "%F{3}z4m%f: element of %Bz4m_retrieve_history%b is not a readable & writable file: %F{1}${file//\%/%%}%f"
      return 1
    fi
  elif [[ -d ${file:h} ]]; then
    if [[ ! -w ${file:h} ]]; then
      print -Pru2 -- "%F{3}z4m%f: element of %Bz4m_retrieve_history%b is in a non-writable directory: %F{1}${file//\%/%%}%f"
      return 1
    fi
  else
    zf_mkdir -p -- ${file:h} || return
  fi
done

if (( $#z4m_ssh_retrieve_files && ! $+commands[base64] )); then
  print -Pru2 -- '%F{3}z4m%f: command not found: %F{1}base64%f'
  return 1
fi

# Load previous sync state
local -A prev_sync_state
local -i has_prev_state=0
if [[ -f $sync_state_file ]]; then
  has_prev_state=1
  local line
  while IFS= read -r line; do
    [[ -n $line && $line != '#'* ]] || continue
    prev_sync_state[${line%%=*}]=${line#*=}
  done < $sync_state_file
fi

# Determine effective sync mode
local effective_sync_mode=$sync_mode
if (( force_sync )); then
  effective_sync_mode='full'
elif [[ $sync_mode == 'smart' ]]; then
  if (( has_prev_state )); then
    effective_sync_mode='incremental'
  else
    effective_sync_mode='full'
  fi
fi

# Compute current file hashes and determine which files need syncing
local -A current_sync_state files_need_sync
local src dst hash
for src dst in ${(kv)z4m_ssh_send_files}; do
  [[ -e $src ]] || continue
  # Compute file hash: md5 (macOS) or md5sum (Linux), fallback to size:mtime
  if (( $+commands[md5] )); then
    hash=$(command md5 -q -- $src 2>/dev/null)
  elif (( $+commands[md5sum] )); then
    hash=$(command md5sum -- $src 2>/dev/null | cut -d' ' -f1)
  else
    local -A fstat
    zstat -H fstat -- $src 2>/dev/null && hash="${fstat[size]}:${fstat[mtime]}" || hash=
  fi
  current_sync_state[$src]=$hash
  if [[ $effective_sync_mode == 'full' ]]; then
    files_need_sync[$src]=1
  elif [[ $effective_sync_mode == 'incremental' ]]; then
    if [[ ${prev_sync_state[$src]:-} != $hash ]]; then
      files_need_sync[$src]=1
    fi
  fi
done

local tmpdir
if (( $+commands[mktemp] )); then
  tmpdir=$(command mktemp -d -- $Z4M/tmp/ssh.XXXXXXXXXX) || return
else
  tmpdir=$Z4M/tmp/ssh.tmp.$sysparams[pid]
  zf_rm -rf -- $tmpdir || return
  zf_mkdir -- $tmpdir || return
fi

{
  # In offline mode, bundle z4m core with the upload
  local z4m_bundle=
  if (( offline_mode )); then
    z4m_bundle=$tmpdir/z4m-bundle.tar.gz
    print -Pru2 -- "%F{3}z4m%f: offline mode - bundling z4m installation..."
    local -a z4m_dirs=(
      zsh4monkey
      fzf/bin
      fzf/man
      powerlevel10k
      zsh-users
      terminfo
    )
    local -a bundle_dirs=()
    local d
    for d in $z4m_dirs; do
      [[ -d $Z4M/$d ]] && bundle_dirs+=($d)
    done
    if (( $#bundle_dirs )); then
      COPYFILE_DISABLE=1 command tar -C $Z4M -czf $z4m_bundle -- $bundle_dirs 2>/dev/null || {
        print -Pru2 -- "%F{3}z4m%f: %F{1}warning%f: failed to create z4m bundle"
        z4m_bundle=
      }
    fi
  fi

  local -i i=0 files_synced=0 files_skipped=0
  local indices=() send_to=()
  for src dst in ${(kv)z4m_ssh_send_files}; do
    (( ++i ))
    send_to+=($dst)
    [[ -e $src ]] || continue
    local target=${src:P}
    if [[ -z $target(#qN.) && -z $target(#qN/) ]]; then
      print -Pru2 -- "%F{3}z4m%f: unsupported file type: %F{1}${src//\%/%%}%f"
      return 1
    fi
    if [[ ${tmpdir:P} == $target(|/*) ]]; then
      print -Pru2 -- "%F{3}z4m%f: cannot send file: %F{1}${src//\%/%%}%f"
      return 1
    fi
    # Incremental sync: only include files that need syncing
    if (( ${+files_need_sync[$src]} )); then
      zf_ln -s -- $target $tmpdir/$i || return
      indices+=($i)
      (( ++files_synced ))
    else
      (( ++files_skipped ))
    fi
  done

  # Show sync stats in incremental mode
  if [[ $effective_sync_mode == 'incremental' && $files_skipped -gt 0 ]]; then
    print -Pru2 -- "%F{3}z4m%f: incremental sync: %F{2}$files_synced%f changed, %F{8}$files_skipped%f unchanged"
  fi

  local -a retrieve_from retrieve_to
  local from to
  for from to in ${(kv)z4m_ssh_retrieve_files}; do
    retrieve_from+=($from)
    retrieve_to+=($to)
  done

  local dump_marker=${(%):-%n}.$sysparams[pid].$EPOCHSECONDS.$RANDOM

  local script
  script=${"$(<$Z4M/zsh4monkey/sc/ssh-bootstrap)"//$'\r'} || return
  script=${script//'^TERM^'/${(q)term}}
  script=${script//'^MIN_VERSION^'/${(q)z4m_min_version}}
  script=${script//'^SSH_HOST^'/${(q)z4m_ssh_host}}
  script=${script//'^SSH_CLIENT^'/${(q)z4m_ssh_client}}
  script=${script//'^SSH_ARGS^'/${(q)${(j: :)@}}}
  script=${script//'^PRELUDE^'/${(F)z4m_ssh_prelude}}
  script=${script//'^SEND_TO^'/${(j: :)send_to}}
  script=${script//'^SETUP^'/${(F)z4m_ssh_setup}}
  script=${script//'^RUN^'/${(F)z4m_ssh_run}}
  script=${script//'^TEARDOWN^'/${(F)z4m_ssh_teardown}}
  if (( $#retrieve_from )); then
    script=${script//'^EMPTY_RETRIEVE_FROM^'/"'false'"}
  else
    script=${script//'^EMPTY_RETRIEVE_FROM^'/"'true'"}
  fi
  script=${script//'^RETRIEVE_FROM^'/${(j: :)retrieve_from}}
  script=${script//'^DUMP_MARKER^'/${(q)dump_marker}}
  script=${script//'^CAN_SAVE_RESTORE_SCREEN^'/${_z4m_can_save_restore_screen}}

  script=${script//'^DUMP_POS^'/${(r:8:: :)${#script}}}

  print -r -- $script >$tmpdir/script || return

  local tar_v tar_c_opt tar_x_opt
  if tar_v=$(command tar --version 2>/dev/null) && [[ $tar_v == *'GNU tar'* ]]; then
    tar_c_opt=(--owner=0 --group=0)
    tar_x_opt=(--warning=no-unknown-keyword --warning=no-timestamp --no-same-owner)
  fi

  local -a tar_files=()
  (( $#indices )) && tar_files+=($indices)
  # Include z4m bundle for offline mode
  if [[ -n $z4m_bundle && -f $z4m_bundle ]]; then
    tar_files+=(${z4m_bundle:t})
  fi
  if (( $#tar_files )); then
    COPYFILE_DISABLE=1 command tar -C $tmpdir $tar_c_opt -czhf - -- $tar_files >>$tmpdir/script || return
  fi

  local args=("$@")
  args[pos[-1],pos[-1]-1]=('-T')
  local remote_script=.z4m-ssh.${(%):-%n}.$sysparams[pid].$EPOCHSECONDS.$RANDOM

  # Tricky corner cases where this command must work:
  #
  #   1. The remote shell is csh (default on FreeBSD).
  #   2. There is no /tmp on the remote host (e.g., Termux).
  #   3. TMPDIR is not set.
  #   4. TMPDIR has spaces in it.
  #
  # The next command (the one that invokes /bin/sh) must also work in these
  # cases. It should also propagate the exit status of /bin/sh.
  local cmd="test -w /tmp && cat >/tmp/$remote_script && echo 1 && exit"
  cmd+=" || "
  cmd+="test ! -e /tmp/$remote_script && cat >~/$remote_script && echo 2"
  local loc
  loc=$("${z4m_ssh_command[@]}" "${args[@]}" $cmd <$tmpdir/script) || return
} always {
  zf_rm -rf -- $tmpdir
}

case ${loc//[[:space:]]} in
  1) remote_script="/tmp/$remote_script";;
  2) remote_script="~/$remote_script";;
  *)
    print -Pru2 -- "%F{3}z4m%f: failed to upload bootstrap script"
    return 1
  ;;
esac

# Save sync state after successful upload
if (( $#current_sync_state )); then
  if [[ ! -d $sync_state_dir ]]; then
    zf_mkdir -p -- $sync_state_dir || true  # Non-fatal: sync still works without state
  fi
  if [[ -d $sync_state_dir ]]; then
    {
      print -r -- "# z4m ssh sync state for $z4m_ssh_host"
      print -r -- "# Last sync: $(strftime '%Y-%m-%d %H:%M:%S' $EPOCHSECONDS)"
      local k v
      for k v in ${(kv)current_sync_state}; do
        print -r -- "${k}=${v}"
      done
    } >$sync_state_file 2>/dev/null || true  # Non-fatal
  fi
fi

args[pos[-1]]='-t'

local stty
if [[ -v commands[stty] && -v _z4m_tty_fd ]]; then
  stty=$(command stty -g <&$_z4m_tty_fd 2>/dev/null) || stty=
fi

{ (  # subshell to avoid TTOU

local -i bypass=0

local -i pid=$sysparams[pid]

{
  setopt no_multi_os
  "${z4m_ssh_command[@]}" "${args[@]}" "sh $remote_script" 2>&1 1>&3 |
     LC_ALL=C command grep -vxE '(Shared c|C)onnection to .* closed\.(.)?' >&2
   return $pipestatus[1]
} 3>&1 | {
  if (( $+commands[mktemp] )); then
    tmpdir=$(command mktemp -d -- $Z4M/tmp/ssh.XXXXXXXXXX) || return
  else
    tmpdir=$Z4M/tmp/ssh.tmp.$sysparams[pid]
    zf_rm -rf -- $tmpdir || return
    zf_mkdir -- $tmpdir || return
  fi

  unsetopt multibyte
  local LC_ALL=C

  unset _z4m_saved_screen

  {
    local buf=
    local mark=$'\001z4m.'$dump_marker
    while true; do
      [[ -n $buf ]] || sysread 'buf[$#buf+1]' || return $(( $? != 5 ))
      if [[ $buf != *$mark[1]* ]]; then
        print -rn -- $buf
        buf=
        continue
      fi
      while true; do
        print -rn -- ${buf%%$mark[1]*}
        buf=$mark[1]${buf#*$mark[1]}
        local -i prefix=$(($#buf < $#mark ? $#buf : $#mark))
        (( prefix )) || continue
        [[ ${buf:0:$prefix} == ${mark:0:$prefix} ]] && break
        print -rn -- $buf[1]
        buf[1]=""
        continue 2
      done
      while (( $#buf < $#mark )) && [[ $mark == $buf* ]]; do
        # What should we do if the output ends with a proper prefix of mark?
        # Print it or not? Return an error or not? We choose to not print and return
        # success iff we've reached eof.
        sysread -s $(($#mark - $#buf)) 'buf[$#buf+1]' && continue
        return $(( $? != 5 ))
      done
      if [[ $buf != $mark* ]]; then
        print -rn -- $buf[1]
        buf[1]=""
        continue
      fi
      buf[1,$#mark]=""
      while (( $#buf < 16 )); do
        sysread -s $((16 - $#buf)) 'buf[$#buf+1]' && continue
        return $(( $? != 5 ))
      done

      {
        case ${buf[1,16]%% #} in
          bypass)
            bypass=1
            break
          ;;
          save-screen)
            (( _z4m_can_save_restore_screen )) || return
            local _z4m_saved_screen=
            -z4m-save-screen || return
            _z4m_saved_screen+=x
            continue
          ;;
          restore-screen)
            [[ -n $_z4m_saved_screen ]] || return
            _z4m_saved_screen[-1]=
            -z4m-restore-screen || return
            unset _z4m_saved_screen
            continue
          ;;
          <->)
            local -i len=buf[1,16]
          ;;
          *)
            return 1
          ;;
        esac
      } always {
        buf=${buf:16}
      }

      (( len )) || continue
      if [[ -d $tmpdir ]]; then
        local dump_file=$tmpdir/dump.base64
      else
        local dump_file=/dev/null
      fi
      {
        local -i n=$((len < $#buf ? len : $#buf))
        print -rn -- $buf[1,n] || return
        (( len -= n ))
        buf[1,n]=""
        while (( len )); do
          sysread -s $((len > 65636 ? 65636 : len)) -o 1 -c n || return $(( $? != 5 ))
          (( len -= n, 1 ))
        done
      } >$dump_file || return
      if [[ $dump_file != /dev/null ]]; then
        if base64 -d <<<'Cg==' &>/dev/null; then
          local base64_opt=-d
        else
          local base64_opt=-D
        fi
        <$tmpdir/dump.base64 command base64 $base64_opt |
          command tar -C $tmpdir $tar_x_opt -xzf - || return
        local -i i
        for i in {1..$#retrieve_to}; do
          local src=$tmpdir/$i
          local dst=$retrieve_to[i]
          [[ -e $src ]] || continue
          if [[ -e $dst ]]; then
            zf_rm -rf -- $dst || return
          fi
          if ! command mv -f -- $src $dst 2>/dev/null; then
            command cp -rf -- $src $dst || return
          fi
        done
        if [[ -s $local_hist_tmp ]]; then
          local local_hist
          for local_hist in $z4m_retrieve_history; do
            local TMPPREFIX=$local_hist
            () {
              () { fc -pa -- $1 $HISTSIZE $SAVEHIST } $1 && zf_mv -f -- $1 $local_hist
            } =(command cat -- $local_hist(N) $local_hist_tmp) || return
          done
        fi
      fi
    done
  } always {
    local -i err=$?
    zf_rm -rf -- $tmpdir $local_hist_tmp
    if (( err )); then
      kill -- -$pid 2>/dev/null
    fi
  }
}

if (( bypass )); then
  setopt no_multi_os
  {
    TERM=${term:-$TERM} "${z4m_ssh_command[@]}" "${args[@]}" 2>&1 1>&3 |
      LC_ALL=C command grep -vxE '(Shared c|C)onnection to .* closed\.(.)?' >&2
    return $pipestatus[1]
  } 3>&1
fi

 ) } always {
  [[ -n $stty ]] && command stty $stty <&$_z4m_tty_fd 2>/dev/null
}
