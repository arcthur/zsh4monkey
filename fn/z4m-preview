#!/usr/bin/env zsh
#
# z4m-preview - Unified preview dispatcher for fzf completion
#
# Usage: z4m-preview <context> <word> [path_prefix]
#
# Arguments:
#   context     - Completion context (e.g., ":complete:git-branch:")
#   word        - The item to preview
#   path_prefix - Optional path prefix for file completions
#

emulate -L zsh -o extended_glob

local ctx=$1 word=$2 path_prefix=$3
local target

# Resolve file path
if [[ -n $path_prefix ]]; then
  target=$path_prefix$word
else
  target=$word
fi

# Delta pager for git output (respects user's delta config)
# Falls back to cat if delta not available
local -a pager
if (( $+commands[delta] )); then
  pager=(delta --paging=never)
else
  pager=(cat)
fi

# Git log format (matches common alias style)
local log_fmt='--pretty=format:%C(yellow)%h%Creset %s %Cgreen(%cr)%Creset %C(bold blue)<%an>%Creset%C(auto)%d%Creset'

# Git commands
case $ctx in
  *:git-branch:*|*:git-switch:*|*:git-merge:*)
    git log --color=always $log_fmt -15 "$word" 2>/dev/null
    return
    ;;
  *:git-checkout:*)
    # Could be branch, file, or commit
    if git show-ref --verify --quiet "refs/heads/$word" 2>/dev/null ||
       git show-ref --verify --quiet "refs/tags/$word" 2>/dev/null ||
       git show-ref --verify --quiet "refs/remotes/origin/$word" 2>/dev/null ||
       [[ -n $(git for-each-ref --format='%(refname:short)' "refs/remotes/*/$word" 2>/dev/null | head -1) ]]; then
      git log --color=always $log_fmt -15 "$word" 2>/dev/null
    elif [[ -e $target ]]; then
      git diff --color=always -- "$target" 2>/dev/null | "${pager[@]}"
    else
      git show --color=always "$word" 2>/dev/null | "${pager[@]}"
    fi
    return
    ;;
  *:git-diff:*|*:git-add:*|*:git-reset:*|*:git-restore:*)
    if [[ -e $target ]]; then
      git diff --color=always -- "$target" 2>/dev/null | "${pager[@]}"
    else
      git diff --color=always "$word" 2>/dev/null | "${pager[@]}"
    fi
    return
    ;;
  *:git-log:*|*:git-revert:*|*:git-cherry-pick:*)
    if [[ -e $target ]]; then
      git log --color=always $log_fmt -15 -- "$target" 2>/dev/null
    else
      git show --color=always "$word" 2>/dev/null | "${pager[@]}"
    fi
    return
    ;;
  *:git-show:*)
    git show --color=always "$word" 2>/dev/null | "${pager[@]}"
    return
    ;;
  *:git-stash:*)
    git stash show --color=always -p "$word" 2>/dev/null | "${pager[@]}"
    return
    ;;
  *:git-rebase:*)
    git log --color=always $log_fmt -15 "$word" 2>/dev/null
    return
    ;;
  *:git-push:*|*:git-pull:*|*:git-fetch:*)
    # Show commits ahead/behind for remote tracking
    if git show-ref --verify --quiet "refs/remotes/$word" 2>/dev/null; then
      echo "Remote: $word"
      git log --color=always $log_fmt -10 "$word" 2>/dev/null
    elif git remote get-url "$word" 2>/dev/null; then
      echo "Remote: $word"
      git remote show "$word" 2>/dev/null | head -20
    fi
    return
    ;;
  *:git-remote:*)
    if git remote get-url "$word" &>/dev/null; then
      echo "URL: $(git remote get-url "$word" 2>/dev/null)"
      echo "Push URL: $(git remote get-url --push "$word" 2>/dev/null)"
      echo ""
      git remote show "$word" 2>/dev/null | head -20
    fi
    return
    ;;
  *:git-tag:*)
    if git show-ref --verify --quiet "refs/tags/$word" 2>/dev/null; then
      git show --color=always "$word" 2>/dev/null | "${pager[@]}"
    fi
    return
    ;;
  *:git-worktree:*)
    git worktree list 2>/dev/null
    return
    ;;
  *:git-blame:*)
    if [[ -e $target ]]; then
      if (( $+commands[bat] )); then
        bat --color=always --style=numbers --line-range=:50 "$target" 2>/dev/null
      else
        head -50 "$target" 2>/dev/null
      fi
    fi
    return
    ;;
  *:git:*)
    # Generic git context (e.g., :complete:git:argument-rest)
    # Auto-detect based on what the word looks like

    # Check local branch
    if git show-ref --verify --quiet "refs/heads/$word" 2>/dev/null; then
      git log --color=always $log_fmt -15 "$word" 2>/dev/null
      return
    fi

    # Check remote branch (origin/main format)
    if git show-ref --verify --quiet "refs/remotes/$word" 2>/dev/null; then
      git log --color=always $log_fmt -15 "$word" 2>/dev/null
      return
    fi

    # Check remote branch (just branch name, search all remotes)
    local remote_ref
    remote_ref=$(git for-each-ref --format='%(refname:short)' "refs/remotes/*/$word" 2>/dev/null | head -1)
    if [[ -n $remote_ref ]]; then
      git log --color=always $log_fmt -15 "$remote_ref" 2>/dev/null
      return
    fi

    # Check tag
    if git show-ref --verify --quiet "refs/tags/$word" 2>/dev/null; then
      git show --color=always "$word" 2>/dev/null | "${pager[@]}"
      return
    fi

    # Check if it's a file with changes
    if [[ -e $target ]]; then
      git diff --color=always -- "$target" 2>/dev/null | "${pager[@]}"
      return
    fi

    # Check if it's a commit or other git object
    if git cat-file -e "$word" 2>/dev/null; then
      git show --color=always "$word" 2>/dev/null | "${pager[@]}"
      return
    fi

    # Check stash entry
    if [[ $word == stash@* ]]; then
      git stash show --color=always -p "$word" 2>/dev/null | "${pager[@]}"
      return
    fi

    # Fallback: try to show something useful
    # Maybe it's a partial ref or alias
    git log --color=always $log_fmt -5 "$word" 2>/dev/null ||
    git show --color=always "$word" 2>/dev/null | head -30
    return
    ;;
esac

# Tmux commands
case $ctx in
  *:tmux:*)
    case $word in
      # Environment
      show-environment|set-environment|showenv|setenv)
        tmux show-environment -g 2>/dev/null
        ;;
      # Options (show current values)
      show-options|set-option|show|set)
        tmux show-options -g 2>/dev/null | head -40
        ;;
      show-window-options|set-window-option|showw|setw)
        tmux show-window-options -g 2>/dev/null | head -40
        ;;
      show-hooks|set-hook)
        tmux show-hooks -g 2>/dev/null
        ;;
      # List commands
      list-sessions|ls)
        tmux list-sessions -F '#{session_name}: #{session_windows} windows (#{session_attached} attached)' 2>/dev/null
        ;;
      list-windows|lsw)
        tmux list-windows -a -F '#{session_name}:#{window_index} #{window_name} #{window_flags}' 2>/dev/null
        ;;
      list-panes|lsp)
        tmux list-panes -a -F '#{session_name}:#{window_index}.#{pane_index} #{pane_current_command} #{pane_width}x#{pane_height}' 2>/dev/null
        ;;
      list-buffers|lsb)
        tmux list-buffers -F '#{buffer_name}: #{buffer_size} bytes' 2>/dev/null
        ;;
      list-keys|lsk)
        tmux list-keys 2>/dev/null | head -40
        ;;
      list-clients|lsc)
        tmux list-clients -F '#{client_name}: #{client_width}x#{client_height} (#{client_termname})' 2>/dev/null
        ;;
      # Session management
      new-session|new)
        tmux list-sessions -F '#{session_name} (#{session_windows}w)' 2>/dev/null
        echo "---"
        echo "Creates new session"
        ;;
      attach-session|attach)
        tmux list-sessions -F '#{?session_attached,*,} #{session_name}: #{session_windows} windows' 2>/dev/null
        ;;
      kill-session)
        tmux list-sessions -F '#{session_name}: #{session_windows} windows' 2>/dev/null
        ;;
      switch-client|switchc)
        tmux list-sessions -F '#{?client_session,>, } #{session_name}' 2>/dev/null
        ;;
      rename-session|rename)
        echo "Current session: $(tmux display-message -p '#{session_name}')"
        ;;
      # Window management
      new-window|neww)
        tmux list-windows -F '#{window_index}: #{window_name} #{window_flags}' 2>/dev/null
        ;;
      select-window|selectw|last-window|last|next-window|next|previous-window|prev)
        tmux list-windows -F '#{window_index}: #{window_name} #{window_flags}' 2>/dev/null
        ;;
      kill-window|killw)
        tmux list-windows -F '#{window_index}: #{window_name} (#{window_panes} panes)' 2>/dev/null
        ;;
      rename-window|renamew)
        echo "Current window: $(tmux display-message -p '#{window_name}')"
        tmux list-windows -F '#{window_index}: #{window_name}' 2>/dev/null
        ;;
      swap-window|swapw|move-window|movew|link-window|linkw|unlink-window|unlinkw)
        tmux list-windows -a -F '#{session_name}:#{window_index} #{window_name}' 2>/dev/null
        ;;
      # Pane management
      select-pane|selectp)
        tmux list-panes -F '#{pane_index}: #{pane_current_command} #{pane_width}x#{pane_height}' 2>/dev/null
        ;;
      kill-pane|killp)
        tmux list-panes -F '#{pane_index}: #{pane_current_command}' 2>/dev/null
        ;;
      split-window|splitw)
        tmux list-panes -F '#{pane_index}: #{pane_current_command} #{pane_width}x#{pane_height}' 2>/dev/null
        ;;
      resize-pane|resizep)
        tmux list-panes -F '#{pane_index}: #{pane_width}x#{pane_height} #{?pane_active,*,}' 2>/dev/null
        ;;
      swap-pane|swapp|move-pane|movep|join-pane|joinp)
        tmux list-panes -a -F '#{session_name}:#{window_index}.#{pane_index} #{pane_current_command}' 2>/dev/null
        ;;
      break-pane|breakp)
        tmux list-panes -F '#{pane_index}: #{pane_current_command}' 2>/dev/null
        ;;
      # Capture/save
      capture-pane|capturep)
        tmux capture-pane -p 2>/dev/null | tail -20
        ;;
      save-buffer|saveb)
        tmux show-buffer 2>/dev/null | head -20
        ;;
      # Display popup info (since you use it)
      display-popup|popup)
        echo "Current popup settings:"
        tmux show-options -g | grep -E '^popup' 2>/dev/null
        ;;
      *)
        # Session/window target - show windows or panes
        if tmux has-session -t "$word" 2>/dev/null; then
          echo "Session: $word"
          tmux list-windows -t "$word" -F '  #{window_index}: #{window_name} #{window_flags} (#{window_panes} panes)' 2>/dev/null
        elif [[ $word == *:* ]]; then
          # Window target (session:window)
          echo "Window: $word"
          tmux list-panes -t "$word" -F '  #{pane_index}: #{pane_current_command} #{pane_width}x#{pane_height}' 2>/dev/null
        fi
        ;;
    esac
    return
    ;;
esac

# Docker commands
case $ctx in
  *:docker:*)
    case $word in
      images|image)
        docker images 2>/dev/null
        ;;
      ps|container)
        docker ps -a 2>/dev/null
        ;;
      volume|volumes)
        docker volume ls 2>/dev/null
        ;;
      network|networks)
        docker network ls 2>/dev/null
        ;;
      *)
        # Container ID or name
        if docker inspect "$word" &>/dev/null; then
          docker inspect --format '{{.Name}} ({{.State.Status}})
Image: {{.Config.Image}}
Created: {{.Created}}
Ports: {{range $p, $conf := .NetworkSettings.Ports}}{{$p}} {{end}}' "$word" 2>/dev/null
        fi
        ;;
    esac
    return
    ;;
esac

# Default: file preview
if [[ -e $target ]]; then
  if [[ -d $target ]]; then
    # Directory: list contents
    if (( $+commands[eza] )); then
      eza --color=always --icons -la "$target" 2>/dev/null
    elif (( $+commands[exa] )); then
      exa --color=always --icons -la "$target" 2>/dev/null
    else
      ls -la "$target" 2>/dev/null
    fi
  elif [[ -f $target ]]; then
    # File: show content with syntax highlighting
    if (( $+commands[bat] )); then
      bat --color=always --style=numbers --line-range=:100 "$target" 2>/dev/null
    elif (( $+commands[batcat] )); then
      batcat --color=always --style=numbers --line-range=:100 "$target" 2>/dev/null
    else
      head -100 "$target" 2>/dev/null
    fi
  else
    # Other: just stat
    ls -la "$target" 2>/dev/null
  fi
fi
