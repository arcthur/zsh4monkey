#!/usr/bin/env zsh
#
# z4m autosuggest - Autosuggestions diagnostics and controls
#
# Usage:
#   z4m autosuggest status [--json] [--init]
#   z4m autosuggest doctor [--json] [--no-init]
#   z4m autosuggest events [--tail N] [--json]
#   z4m autosuggest reset [--json]

emulate -L zsh -o typeset_silent -o pipe_fail -o extended_glob \
  -o prompt_percent -o no_prompt_subst -o no_prompt_bang -o no_bg_nice -o no_aliases

function -z4m-cmd-autosuggest-usage() {
  print -Pru2 -- "Usage: %F{2}z4m%f %Bautosuggest%b [status|doctor|events|reset] [options]"
  print -Pru2 -- ""
  print -Pru2 -- "Subcommands:"
  print -Pru2 -- "  %Bstatus%b [--json] [--init]      Show autosuggest status"
  print -Pru2 -- "  %Bdoctor%b [--json] [--init|--no-init]   Run autosuggest checks"
  print -Pru2 -- "  %Bevents%b [--tail N] [--json]    Show autosuggest lifecycle events"
  print -Pru2 -- "  %Breset%b [--json]                Reset autosuggest runtime state"
}

function -z4m-cmd-autosuggest-json-escape() {
  local value=$1
  value=${value//\\/\\\\}
  value=${value//\"/\\\"}
  value=${value//$'\n'/\\n}
  value=${value//$'\r'/\\r}
  value=${value//$'\t'/\\t}
  value=${value//$'\b'/\\b}
  value=${value//$'\f'/\\f}
  # Strip remaining C0 control characters (U+0000â€“U+001F) except those already handled
  value=${value//[[:cntrl:]]/}
  print -rn -- "$value"
}

function -z4m-cmd-autosuggest-load-core() {
  (( ${+functions[-z4m-autosuggest-core-status]} )) || -z4m-autosuggest-core || return 1
}

function -z4m-cmd-autosuggest-load-status-map() {
  typeset -gA _z4m_autosuggest_cmd_status
  _z4m_autosuggest_cmd_status=()

  local -a lines
  lines=("${(@f)$(-z4m-autosuggest-core-status)}")

  local line key value
  for line in "${lines[@]}"; do
    key=${line%%=*}
    value=${line#*=}
    _z4m_autosuggest_cmd_status[$key]=$value
  done
}

function -z4m-cmd-autosuggest-status() {
  local -i json=0 do_init=0
  while (( $# )); do
    case $1 in
      --json) json=1 ;;
      --init) do_init=1 ;;
      *)
        print -Pru2 -- "%F{3}z4m%f: %Bautosuggest status%b: unknown option: %F{1}${1//\%/%%}%f"
        return 1
        ;;
    esac
    shift
  done

  (( do_init )) && -z4m-autosuggest-init || true
  -z4m-cmd-autosuggest-load-status-map

  local configured_enabled=${_z4m_autosuggest_cmd_status[configured_enabled]-1}
  local configured_strategy=${_z4m_autosuggest_cmd_status[configured_strategy]-history}
  local configured_buffer_min_size=${_z4m_autosuggest_cmd_status[configured_buffer_min_size]-}
  local configured_match_prev_max_cmds=${_z4m_autosuggest_cmd_status[configured_match_prev_max_cmds]-200}
  local configured_match_prev_cmd_count=${_z4m_autosuggest_cmd_status[configured_match_prev_cmd_count]-1}
  local configured_case_insensitive=${_z4m_autosuggest_cmd_status[configured_case_insensitive]-0}
  local configured_pwd_scan_limit=${_z4m_autosuggest_cmd_status[configured_pwd_scan_limit]-500}
  local active_strategy=${_z4m_autosuggest_cmd_status[active_strategy]-none}
  local active_provider=${_z4m_autosuggest_cmd_status[active_provider]-none}
  local state=${_z4m_autosuggest_cmd_status[state]-uninitialized}
  local initialized=${_z4m_autosuggest_cmd_status[initialized]-0}
  local runtime_enabled=${_z4m_autosuggest_cmd_status[runtime_enabled]-0}
  local event_count=${_z4m_autosuggest_cmd_status[event_count]-0}
  local last_error=${_z4m_autosuggest_cmd_status[last_error]-}
  local zas_version=${_z4m_autosuggest_cmd_status[zas_version]-unknown}
  local zas_commit=${_z4m_autosuggest_cmd_status[zas_commit]-unknown}
  local ai_configured_enabled=${_z4m_autosuggest_cmd_status[ai_configured_enabled]-0}
  local ai_enabled=${_z4m_autosuggest_cmd_status[ai_enabled]-0}
  local ai_api_key_present=${_z4m_autosuggest_cmd_status[ai_api_key_present]-0}
  local ai_endpoint=${_z4m_autosuggest_cmd_status[ai_endpoint]-}
  local ai_model=${_z4m_autosuggest_cmd_status[ai_model]-}
  local ai_api_key_env=${_z4m_autosuggest_cmd_status[ai_api_key_env]-DEEPSEEK_API_KEY}
  local ai_auth_header_enabled=${_z4m_autosuggest_cmd_status[ai_auth_header_enabled]-0}
  local ai_mode=${_z4m_autosuggest_cmd_status[ai_mode]-passive}
  local ai_timeout_ms=${_z4m_autosuggest_cmd_status[ai_timeout_ms]-700}
  local ai_debounce_ms=${_z4m_autosuggest_cmd_status[ai_debounce_ms]-160}
  local ai_cooldown_ms=${_z4m_autosuggest_cmd_status[ai_cooldown_ms]-800}
  local ai_min_input=${_z4m_autosuggest_cmd_status[ai_min_input]-2}
  local ai_max_input_tokens=${_z4m_autosuggest_cmd_status[ai_max_input_tokens]-384}
  local ai_max_output_tokens=${_z4m_autosuggest_cmd_status[ai_max_output_tokens]-96}
  local ai_history_lines=${_z4m_autosuggest_cmd_status[ai_history_lines]-6}
  local ai_budget_per_minute=${_z4m_autosuggest_cmd_status[ai_budget_per_minute]-12000}
  local ai_budget_per_day=${_z4m_autosuggest_cmd_status[ai_budget_per_day]-300000}
  local ai_budget_minute_used=${_z4m_autosuggest_cmd_status[ai_budget_minute_used]-0}
  local ai_budget_day_used=${_z4m_autosuggest_cmd_status[ai_budget_day_used]-0}
  local ai_budget_minute_remaining=${_z4m_autosuggest_cmd_status[ai_budget_minute_remaining]-12000}
  local ai_budget_day_remaining=${_z4m_autosuggest_cmd_status[ai_budget_day_remaining]-300000}
  local ai_inflight=${_z4m_autosuggest_cmd_status[ai_inflight]-0}
  local ai_last_latency_ms=${_z4m_autosuggest_cmd_status[ai_last_latency_ms]-0}
  local ai_last_reject=${_z4m_autosuggest_cmd_status[ai_last_reject]-}
  local ai_last_http_code=${_z4m_autosuggest_cmd_status[ai_last_http_code]-}
  local ai_last_error=${_z4m_autosuggest_cmd_status[ai_last_error]-}

  if (( json )); then
    local enabled_json=false initialized_json=false runtime_json=false
    (( configured_enabled )) && enabled_json=true
    (( initialized )) && initialized_json=true
    (( runtime_enabled )) && runtime_json=true
    local -i event_count_i=${event_count:-0}
    print -rn -- "{"
    print -rn -- "\"configured_enabled\":$enabled_json,"
    print -rn -- "\"configured_strategy\":\"$(-z4m-cmd-autosuggest-json-escape "$configured_strategy")\","
    if [[ -z $configured_buffer_min_size ]]; then
      print -rn -- "\"configured_buffer_min_size\":null,"
    else
      print -rn -- "\"configured_buffer_min_size\":$configured_buffer_min_size,"
    fi
    print -rn -- "\"configured_match_prev_max_cmds\":$configured_match_prev_max_cmds,"
    print -rn -- "\"configured_match_prev_cmd_count\":$configured_match_prev_cmd_count,"
    local ci_json=false
    (( configured_case_insensitive )) && ci_json=true
    print -rn -- "\"configured_case_insensitive\":$ci_json,"
    print -rn -- "\"configured_pwd_scan_limit\":$configured_pwd_scan_limit,"
    print -rn -- "\"active_strategy\":\"$(-z4m-cmd-autosuggest-json-escape "$active_strategy")\","
    print -rn -- "\"active_provider\":\"$(-z4m-cmd-autosuggest-json-escape "$active_provider")\","
    print -rn -- "\"state\":\"$(-z4m-cmd-autosuggest-json-escape "$state")\","
    print -rn -- "\"initialized\":$initialized_json,"
    print -rn -- "\"runtime_enabled\":$runtime_json,"
    print -rn -- "\"event_count\":$event_count_i,"
    if [[ -z $last_error ]]; then
      print -rn -- "\"last_error\":null,"
    else
      print -rn -- "\"last_error\":\"$(-z4m-cmd-autosuggest-json-escape "$last_error")\","
    fi
    print -rn -- "\"zas_version\":\"$(-z4m-cmd-autosuggest-json-escape "$zas_version")\","
    print -rn -- "\"zas_commit\":\"$(-z4m-cmd-autosuggest-json-escape "$zas_commit")\","
    local ai_configured_json=false ai_enabled_json=false ai_key_json=false ai_inflight_json=false
    (( ai_configured_enabled )) && ai_configured_json=true
    (( ai_enabled )) && ai_enabled_json=true
    (( ai_api_key_present )) && ai_key_json=true
    (( ai_inflight )) && ai_inflight_json=true
    print -rn -- "\"ai\":{\"configured_enabled\":$ai_configured_json,"
    print -rn -- "\"enabled\":$ai_enabled_json,"
    print -rn -- "\"api_key_present\":$ai_key_json,"
    print -rn -- "\"endpoint\":\"$(-z4m-cmd-autosuggest-json-escape "$ai_endpoint")\","
    print -rn -- "\"model\":\"$(-z4m-cmd-autosuggest-json-escape "$ai_model")\","
    print -rn -- "\"api_key_env\":\"$(-z4m-cmd-autosuggest-json-escape "$ai_api_key_env")\","
    local ai_auth_header_json=false
    (( ai_auth_header_enabled )) && ai_auth_header_json=true
    print -rn -- "\"auth_header_enabled\":$ai_auth_header_json,"
    print -rn -- "\"mode\":\"$(-z4m-cmd-autosuggest-json-escape "$ai_mode")\","
    print -rn -- "\"timeout_ms\":$ai_timeout_ms,"
    print -rn -- "\"debounce_ms\":$ai_debounce_ms,"
    print -rn -- "\"cooldown_ms\":$ai_cooldown_ms,"
    print -rn -- "\"min_input\":$ai_min_input,"
    print -rn -- "\"max_input_tokens\":$ai_max_input_tokens,"
    print -rn -- "\"max_output_tokens\":$ai_max_output_tokens,"
    print -rn -- "\"history_lines\":$ai_history_lines,"
    print -rn -- "\"budget_per_minute\":$ai_budget_per_minute,"
    print -rn -- "\"budget_per_day\":$ai_budget_per_day,"
    print -rn -- "\"budget_minute_used\":$ai_budget_minute_used,"
    print -rn -- "\"budget_day_used\":$ai_budget_day_used,"
    print -rn -- "\"budget_minute_remaining\":$ai_budget_minute_remaining,"
    print -rn -- "\"budget_day_remaining\":$ai_budget_day_remaining,"
    print -rn -- "\"inflight\":$ai_inflight_json,"
    print -rn -- "\"last_latency_ms\":$ai_last_latency_ms,"
    if [[ -z $ai_last_reject ]]; then
      print -rn -- "\"last_reject\":null,"
    else
      print -rn -- "\"last_reject\":\"$(-z4m-cmd-autosuggest-json-escape "$ai_last_reject")\","
    fi
    if [[ -z $ai_last_http_code ]]; then
      print -rn -- "\"last_http_code\":null,"
    else
      print -rn -- "\"last_http_code\":\"$(-z4m-cmd-autosuggest-json-escape "$ai_last_http_code")\","
    fi
    if [[ -z $ai_last_error ]]; then
      print -rn -- "\"last_error\":null"
    else
      print -rn -- "\"last_error\":\"$(-z4m-cmd-autosuggest-json-escape "$ai_last_error")\""
    fi
    print -rn -- "}"
    print -r -- "}"
    return 0
  fi

  print -Pr -- "%F{3}z4m%f: autosuggest status"
  print -Pr -- "  configured enabled: ${configured_enabled}"
  print -Pr -- "  configured strategy:${configured_strategy}"
  if [[ -z $configured_buffer_min_size ]]; then
    print -Pr -- "  buffer min size:     none"
  else
    print -Pr -- "  buffer min size:     ${configured_buffer_min_size}"
  fi
  print -Pr -- "  match prev max cmds: ${configured_match_prev_max_cmds}"
  print -Pr -- "  match prev cmd cnt:  ${configured_match_prev_cmd_count}"
  print -Pr -- "  case insensitive:   ${configured_case_insensitive}"
  print -Pr -- "  pwd scan limit:     ${configured_pwd_scan_limit}"
  print -Pr -- "  active strategy:    ${active_strategy}"
  print -Pr -- "  active provider:    ${active_provider}"
  print -Pr -- "  lifecycle state:    ${state}"
  print -Pr -- "  initialized:        ${initialized}"
  print -Pr -- "  runtime enabled:    ${runtime_enabled}"
  print -Pr -- "  events buffered:    ${event_count}"
  print -Pr -- "  vendor version:     ${zas_version}"
  if [[ $zas_commit == unknown ]]; then
    print -Pr -- "  vendor commit:      ${zas_commit}"
  else
    print -Pr -- "  vendor commit:      ${zas_commit[1,12]}"
  fi
  print -Pr -- "  ai configured:      ${ai_configured_enabled}"
  print -Pr -- "  ai enabled:         ${ai_enabled}"
  print -Pr -- "  ai mode:            ${ai_mode}"
  print -Pr -- "  ai model:           ${ai_model}"
  print -Pr -- "  ai endpoint:        ${ai_endpoint}"
  print -Pr -- "  ai api key env:     ${ai_api_key_env} (present=${ai_api_key_present})"
  print -Pr -- "  ai auth header:     ${ai_auth_header_enabled}"
  print -Pr -- "  ai timeout ms:      ${ai_timeout_ms}"
  print -Pr -- "  ai debounce ms:     ${ai_debounce_ms}"
  print -Pr -- "  ai cooldown ms:     ${ai_cooldown_ms}"
  print -Pr -- "  ai min input:       ${ai_min_input}"
  print -Pr -- "  ai input/output tk: ${ai_max_input_tokens}/${ai_max_output_tokens}"
  print -Pr -- "  ai history lines:   ${ai_history_lines}"
  print -Pr -- "  ai budget min/day:  ${ai_budget_per_minute}/${ai_budget_per_day}"
  print -Pr -- "  ai used min/day:    ${ai_budget_minute_used}/${ai_budget_day_used}"
  print -Pr -- "  ai remain min/day:  ${ai_budget_minute_remaining}/${ai_budget_day_remaining}"
  print -Pr -- "  ai inflight:        ${ai_inflight}"
  print -Pr -- "  ai last latency ms: ${ai_last_latency_ms}"
  [[ -z $ai_last_reject ]] || print -Pr -- "  ai last reject:     ${ai_last_reject}"
  [[ -z $ai_last_http_code ]] || print -Pr -- "  ai last http code:  ${ai_last_http_code}"
  [[ -z $ai_last_error ]] || print -Pr -- "  ai last error:      ${ai_last_error}"
  [[ -z $last_error ]] || print -Pr -- "  last error:         ${last_error}"
}

function -z4m-cmd-autosuggest-doctor() {
  local -i json=0 do_init=1
  while (( $# )); do
    case $1 in
      --json) json=1 ;;
      --init) do_init=1 ;;
      --no-init) do_init=0 ;;
      *)
        print -Pru2 -- "%F{3}z4m%f: %Bautosuggest doctor%b: unknown option: %F{1}${1//\%/%%}%f"
        return 1
        ;;
    esac
    shift
  done

  (( do_init )) && -z4m-autosuggest-init || true
  -z4m-cmd-autosuggest-load-status-map

  local state=${_z4m_autosuggest_cmd_status[state]-uninitialized}
  local configured_strategy=${_z4m_autosuggest_cmd_status[configured_strategy]-history}
  local configured_enabled=${_z4m_autosuggest_cmd_status[configured_enabled]-1}
  local configured_buffer_min_size=${_z4m_autosuggest_cmd_status[configured_buffer_min_size]-}
  local configured_match_prev_max_cmds=${_z4m_autosuggest_cmd_status[configured_match_prev_max_cmds]-200}
  local configured_match_prev_cmd_count=${_z4m_autosuggest_cmd_status[configured_match_prev_cmd_count]-1}
  local last_error=${_z4m_autosuggest_cmd_status[last_error]-}
  local ai_configured_enabled=${_z4m_autosuggest_cmd_status[ai_configured_enabled]-0}
  local ai_enabled=${_z4m_autosuggest_cmd_status[ai_enabled]-0}
  local ai_api_key_present=${_z4m_autosuggest_cmd_status[ai_api_key_present]-0}
  local ai_mode=${_z4m_autosuggest_cmd_status[ai_mode]-passive}
  local ai_model=${_z4m_autosuggest_cmd_status[ai_model]-}
  local ai_endpoint=${_z4m_autosuggest_cmd_status[ai_endpoint]-}
  local ai_auth_header_enabled=${_z4m_autosuggest_cmd_status[ai_auth_header_enabled]-0}
  local ai_timeout_ms=${_z4m_autosuggest_cmd_status[ai_timeout_ms]-700}
  local ai_max_input_tokens=${_z4m_autosuggest_cmd_status[ai_max_input_tokens]-384}
  local ai_max_output_tokens=${_z4m_autosuggest_cmd_status[ai_max_output_tokens]-96}
  local ai_budget_per_minute=${_z4m_autosuggest_cmd_status[ai_budget_per_minute]-12000}
  local ai_budget_per_day=${_z4m_autosuggest_cmd_status[ai_budget_per_day]-300000}
  local ai_budget_minute_used=${_z4m_autosuggest_cmd_status[ai_budget_minute_used]-0}
  local ai_budget_day_used=${_z4m_autosuggest_cmd_status[ai_budget_day_used]-0}
  local ai_last_reject=${_z4m_autosuggest_cmd_status[ai_last_reject]-}

  local -a checks
  local -i errors=0 warnings=0

  if [[ $configured_enabled == (0|1) ]]; then
    checks+=("ok"$'\t'"config"$'\t'"configured enabled is ${configured_enabled}")
  else
    checks+=("error"$'\t'"config"$'\t'"configured enabled is invalid: ${configured_enabled}")
    (( errors++ ))
  fi

  local -a strategy_words=(${=configured_strategy})
  local -i strategy_valid=1
  local sw
  for sw in $strategy_words; do
    case $sw in
      history|match_prev_cmd|history_pwd) ;;
      *) strategy_valid=0; break ;;
    esac
  done
  if (( ${#strategy_words} == 0 )); then
    strategy_valid=0
  fi
  if (( strategy_valid )); then
    checks+=("ok"$'\t'"config"$'\t'"configured strategy is ${configured_strategy}")
  else
    checks+=("error"$'\t'"config"$'\t'"configured strategy is invalid: ${configured_strategy}")
    (( errors++ ))
  fi

  if [[ -z $configured_buffer_min_size || $configured_buffer_min_size == <-> ]]; then
    checks+=("ok"$'\t'"config"$'\t'"buffer min size is ${configured_buffer_min_size:-none}")
  else
    checks+=("error"$'\t'"config"$'\t'"buffer min size is invalid: ${configured_buffer_min_size}")
    (( errors++ ))
  fi

  if [[ $configured_match_prev_max_cmds == -1 || $configured_match_prev_max_cmds == <-> ]]; then
    if (( configured_match_prev_max_cmds == -1 || configured_match_prev_max_cmds > 0 )); then
      checks+=("ok"$'\t'"config"$'\t'"match prev max cmds is ${configured_match_prev_max_cmds}")
    else
      checks+=("error"$'\t'"config"$'\t'"match prev max cmds is invalid: ${configured_match_prev_max_cmds}")
      (( errors++ ))
    fi
  else
    checks+=("error"$'\t'"config"$'\t'"match prev max cmds is invalid: ${configured_match_prev_max_cmds}")
    (( errors++ ))
  fi

  if [[ $configured_match_prev_cmd_count == <-> ]] && (( configured_match_prev_cmd_count > 0 )); then
    checks+=("ok"$'\t'"config"$'\t'"match prev cmd count is ${configured_match_prev_cmd_count}")
  else
    checks+=("error"$'\t'"config"$'\t'"match prev cmd count is invalid: ${configured_match_prev_cmd_count}")
    (( errors++ ))
  fi

  if [[ $state == (ready|disabled|degraded|initializing|uninitialized) ]]; then
    checks+=("ok"$'\t'"runtime"$'\t'"lifecycle state is ${state}")
  else
    checks+=("error"$'\t'"runtime"$'\t'"invalid lifecycle state: ${state}")
    (( errors++ ))
  fi

  local fn
  for fn in _zsh_autosuggest_start _zsh_autosuggest_fetch_suggestion; do
    if (( ${+functions[$fn]} )); then
      checks+=("ok"$'\t'"runtime"$'\t'"function present: ${fn}")
    else
      if [[ $state == disabled || ( $state == uninitialized && $do_init == 0 ) ]]; then
        checks+=("warn"$'\t'"runtime"$'\t'"function not loaded yet: ${fn}")
        (( warnings++ ))
      else
        checks+=("error"$'\t'"runtime"$'\t'"missing function: ${fn}")
        (( errors++ ))
      fi
    fi
  done

  local vendor_dir=$Z4M/zsh4monkey/vendor/zsh-autosuggestions
  if [[ -r $vendor_dir/zsh-autosuggestions.zsh ]]; then
    checks+=("ok"$'\t'"vendor"$'\t'"vendor source file is present")
  else
    checks+=("error"$'\t'"vendor"$'\t'"missing vendor source file")
    (( errors++ ))
  fi
  if [[ -r $vendor_dir/.z4m-vendor-meta ]]; then
    checks+=("ok"$'\t'"vendor"$'\t'"vendor metadata file is present")
  else
    checks+=("warn"$'\t'"vendor"$'\t'"vendor metadata file is missing")
    (( warnings++ ))
  fi

  if (( ${+Z4M_ZAS_LIBRARY_MODE} )); then
    checks+=("ok"$'\t'"mode"$'\t'"library mode is enabled")
  elif [[ $state == ready ]]; then
    checks+=("warn"$'\t'"mode"$'\t'"library mode is not enabled")
    (( warnings++ ))
  fi

  if (( ${+Z4M_ZAS_EXTERNAL_HIGHLIGHT} )); then
    checks+=("ok"$'\t'"mode"$'\t'"external highlight handoff is enabled")
  elif [[ $state == ready ]]; then
    checks+=("warn"$'\t'"mode"$'\t'"external highlight handoff is not enabled")
    (( warnings++ ))
  fi

  if [[ $state == degraded ]]; then
    checks+=("warn"$'\t'"state"$'\t'"autosuggest subsystem is degraded")
    (( warnings++ ))
  elif [[ $state == disabled ]]; then
    checks+=("ok"$'\t'"state"$'\t'"autosuggest subsystem is disabled")
  elif [[ $state == ready ]]; then
    checks+=("ok"$'\t'"state"$'\t'"autosuggest subsystem is ready")
  fi

  [[ -z $last_error ]] || {
    checks+=("warn"$'\t'"state"$'\t'"last error: ${last_error}")
    (( warnings++ ))
  }

  if [[ $ai_configured_enabled == (0|1) ]]; then
    checks+=("ok"$'\t'"ai"$'\t'"ai configured flag is ${ai_configured_enabled}")
  else
    checks+=("error"$'\t'"ai"$'\t'"ai configured flag is invalid: ${ai_configured_enabled}")
    (( errors++ ))
  fi

  if [[ $ai_mode == (manual|passive|auto) ]]; then
    checks+=("ok"$'\t'"ai"$'\t'"ai mode is ${ai_mode}")
  else
    checks+=("error"$'\t'"ai"$'\t'"ai mode is invalid: ${ai_mode}")
    (( errors++ ))
  fi

  if [[ -n $ai_model && -n $ai_endpoint ]]; then
    checks+=("ok"$'\t'"ai"$'\t'"ai endpoint/model configured")
  elif [[ $ai_configured_enabled == 1 ]]; then
    checks+=("error"$'\t'"ai"$'\t'"ai endpoint or model is empty")
    (( errors++ ))
  fi

  if [[ $ai_timeout_ms == <-> ]] && (( ai_timeout_ms > 0 )); then
    checks+=("ok"$'\t'"ai"$'\t'"ai timeout is ${ai_timeout_ms}ms")
  else
    checks+=("error"$'\t'"ai"$'\t'"ai timeout is invalid: ${ai_timeout_ms}")
    (( errors++ ))
  fi

  if [[ $ai_max_input_tokens == <-> ]] && (( ai_max_input_tokens > 0 )) &&
     [[ $ai_max_output_tokens == <-> ]] && (( ai_max_output_tokens > 0 )); then
    checks+=("ok"$'\t'"ai"$'\t'"ai token bounds in=${ai_max_input_tokens} out=${ai_max_output_tokens}")
  else
    checks+=("error"$'\t'"ai"$'\t'"ai token bounds are invalid")
    (( errors++ ))
  fi

  if [[ $ai_budget_per_minute == <-> ]] && (( ai_budget_per_minute > 0 )) &&
     [[ $ai_budget_per_day == <-> ]] && (( ai_budget_per_day > 0 )); then
    checks+=("ok"$'\t'"ai"$'\t'"ai token budget min/day=${ai_budget_per_minute}/${ai_budget_per_day}")
  else
    checks+=("error"$'\t'"ai"$'\t'"ai token budget is invalid")
    (( errors++ ))
  fi

  if [[ $ai_budget_minute_used == <-> ]] && [[ $ai_budget_day_used == <-> ]]; then
    checks+=("ok"$'\t'"ai"$'\t'"ai budget usage min/day=${ai_budget_minute_used}/${ai_budget_day_used}")
  else
    checks+=("error"$'\t'"ai"$'\t'"ai budget usage is invalid")
    (( errors++ ))
  fi

  if [[ $ai_auth_header_enabled == (0|1) ]]; then
    checks+=("ok"$'\t'"ai"$'\t'"ai auth header enabled is ${ai_auth_header_enabled}")
  else
    checks+=("error"$'\t'"ai"$'\t'"ai auth header enabled is invalid: ${ai_auth_header_enabled}")
    (( errors++ ))
  fi
  if [[ $ai_configured_enabled == 1 ]]; then
    if [[ $ai_api_key_present == 1 && $ai_auth_header_enabled == 1 ]]; then
      checks+=("ok"$'\t'"ai"$'\t'"ai token is present and auth header is enabled")
    elif [[ $ai_api_key_present == 0 ]]; then
      checks+=("error"$'\t'"ai"$'\t'"ai is enabled but api key is missing")
      (( errors++ ))
    else
      checks+=("error"$'\t'"ai"$'\t'"ai api key exists but auth header is disabled")
      (( errors++ ))
    fi
  fi

  if [[ $ai_configured_enabled == 1 ]]; then
    if [[ $ai_enabled == 1 ]]; then
      checks+=("ok"$'\t'"ai"$'\t'"ai runtime is enabled")
    else
      checks+=("warn"$'\t'"ai"$'\t'"ai is configured but currently inactive")
      (( warnings++ ))
    fi
  else
    checks+=("ok"$'\t'"ai"$'\t'"ai lane is disabled")
  fi

  if [[ -n $ai_last_reject ]]; then
    case $ai_last_reject in
      finish|reset|disabled|manual_mode|empty_buffer|below_min_input|debounce_wait|inflight|cooldown|retrying_strict|low_quality|numeric_tail|prefix_mismatch|no_delta|multiline|control_chars|invalid_head|unknown_command)
        checks+=("ok"$'\t'"ai"$'\t'"ai last reject reason is expected: ${ai_last_reject}")
        ;;
      *)
        checks+=("warn"$'\t'"ai"$'\t'"ai last reject reason: ${ai_last_reject}")
        (( warnings++ ))
        ;;
    esac
  fi

  local -i code=0
  if (( errors )); then
    code=2
  elif (( warnings )); then
    code=1
  fi

  if (( json )); then
    local health=ok
    (( code == 1 )) && health=warn
    (( code == 2 )) && health=error
    print -rn -- '{"summary":{'
    print -rn -- "\"health\":\"$health\",\"errors\":$errors,\"warnings\":$warnings"
    print -rn -- '},"checks":['

    local -i i
    local level name message sep=
    for (( i = 1; i <= $#checks; i++ )); do
      IFS=$'\t' read -r level name message <<< "${checks[i]}"
      print -rn -- "${sep}{\"level\":\"$(-z4m-cmd-autosuggest-json-escape "$level")\",\"name\":\"$(-z4m-cmd-autosuggest-json-escape "$name")\",\"message\":\"$(-z4m-cmd-autosuggest-json-escape "$message")\"}"
      sep=","
    done
    print -r -- "]}"
    return $code
  fi

  print -Pr -- "%F{3}z4m%f: autosuggest doctor"
  local level name check_message color entry
  for entry in "${checks[@]}"; do
    IFS=$'\t' read -r level name check_message <<< "$entry"
    case $level in
      ok)    level=OK; color=2 ;;
      warn)  level=WARN; color=3 ;;
      error) level=ERROR; color=1 ;;
      *)     color=7 ;;
    esac
    print -Pr -- "  %F{$color}[$level]%f ${name}: ${check_message}"
  done
  print -Pr -- ""
  print -Pr -- "  summary: errors=${errors} warnings=${warnings}"
  return $code
}

function -z4m-cmd-autosuggest-events() {
  local -i json=0 tail=20
  while (( $# )); do
    case $1 in
      --json) json=1 ;;
      --tail)
        shift
        if (( $# == 0 )) || [[ $1 != <-> ]]; then
          print -Pru2 -- "%F{3}z4m%f: %Bautosuggest events%b: --tail requires a non-negative integer"
          return 1
        fi
        tail=$1
        ;;
      *)
        print -Pru2 -- "%F{3}z4m%f: %Bautosuggest events%b: unknown option: %F{1}${1//\%/%%}%f"
        return 1
        ;;
    esac
    shift
  done

  local -a events=("${_z4m_autosuggest_events[@]}")
  if (( tail > 0 && $#events > tail )); then
    events=("${(@)events[-$tail,-1]}")
  fi

  if (( json )); then
    print -rn -- '{"count":'"${#events}"',"events":['
    local -i i
    local ts level event message sep=
    for (( i = 1; i <= $#events; i++ )); do
      IFS=$'\t' read -r ts level event message <<< "${events[i]}"
      print -rn -- "${sep}{\"time\":\"$(-z4m-cmd-autosuggest-json-escape "$ts")\",\"level\":\"$(-z4m-cmd-autosuggest-json-escape "$level")\",\"event\":\"$(-z4m-cmd-autosuggest-json-escape "$event")\",\"message\":\"$(-z4m-cmd-autosuggest-json-escape "$message")\"}"
      sep=","
    done
    print -r -- "]}"
    return 0
  fi

  print -Pr -- "%F{3}z4m%f: autosuggest events (showing ${#events})"
  if (( $#events == 0 )); then
    print -Pr -- "  no autosuggest events recorded yet"
    return 0
  fi

  local entry ts level event message
  for entry in "${events[@]}"; do
    IFS=$'\t' read -r ts level event message <<< "$entry"
    printf '  %-17s %-5s %-10s %s\n' "$ts" "$level" "$event" "$message"
  done
}

function -z4m-cmd-autosuggest-reset() {
  local -i json=0
  while (( $# )); do
    case $1 in
      --json) json=1 ;;
      *)
        print -Pru2 -- "%F{3}z4m%f: %Bautosuggest reset%b: unknown option: %F{1}${1//\%/%%}%f"
        return 1
        ;;
    esac
    shift
  done

  -z4m-autosuggest-reset cmd
  if (( json )); then
    print -r -- '{"result":"ok"}'
  else
    print -Pr -- "%F{3}z4m%f: autosuggest state reset"
  fi
}

-z4m-cmd-autosuggest-load-core || return 1

local subcmd=status
if (( ARGC )) && [[ $1 != --* ]]; then
  subcmd=$1
  shift
fi

case $subcmd in
  status) -z4m-cmd-autosuggest-status "$@" ;;
  doctor) -z4m-cmd-autosuggest-doctor "$@" ;;
  events) -z4m-cmd-autosuggest-events "$@" ;;
  reset)  -z4m-cmd-autosuggest-reset "$@" ;;
  help|-h|--help)
    -z4m-cmd-autosuggest-usage
    ;;
  *)
    print -Pru2 -- "%F{3}z4m%f: %Bautosuggest%b: unknown subcommand: %F{1}${subcmd//\%/%%}%f"
    print -Pru2 -- ""
    -z4m-cmd-autosuggest-usage
    return 1
    ;;
esac
