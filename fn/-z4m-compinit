#!/usr/bin/env zsh

emulate -L zsh -o typeset_silent -o pipe_fail -o extended_glob \
    -o prompt_percent -o no_prompt_subst -o no_prompt_bang -o no_bg_nice -o no_aliases

if [[ -v _z4m_compinit_fd ]]; then
  zle -F $_z4m_compinit_fd
  exec {_z4m_compinit_fd}>&-
  unset _z4m_compinit_fd
fi

unfunction compdef

local -aU editors=(
  vi vim nvim emacs nano gedit code kak kate mcedit joe $EDITOR $VISUAL
  bat cat less more $PAGER)
zstyle ':completion:*:*:('${(j:|:)editors}'):*:*' ignored-patterns '*.zwc'

zstyle ':completion:*' list-colors "${(@s.:.)LS_COLORS}"

(( _z4m_use[zsh-completions] )) &&
  [[ -d $Z4M/zsh-completions/src ]] &&
  fpath+=($Z4M/zsh-completions/src)

if (( !_z4m_dangerous_root )) && zstyle -t ':completion::complete:' use-cache; then
  local cache
  zstyle -s ':completion::complete:' cache-path cache
  : ${cache:=${ZDOTDIR:-~}/.zcompcache}
  if [[ ! -e $cache ]]; then
    zf_mkdir -m 0700 -p -- $cache
  fi
fi

local dump
zstyle -s ':z4m:compinit' dump-path dump
: ${dump:=$Z4M/cache/zcompdump-$EUID-$ZSH_VERSION}

local -a stat files=(${^fpath}/^([^_]*|*~|*.zwc)(-.N))
(( ! $#files )) || zstat -A stat +mtime -- $files
local real_sig=($ZSH_VERSION $ZSH_PATCHLEVEL $files $stat)
real_sig='# '${(V)${(pj:\0:)real_sig}}$'\n'

local sig
if [[ -r $dump ]] &&
    sysread -s $#real_sig sig <$dump        &&
    [[ $sig == $real_sig && -r $dump.zwc ]] &&
    zstat -A stat +mtime -- $dump $dump.zwc &&
    (( stat[2] == stat[1] + 1 )); then
  -z4m-compinit-impl -C -d $dump
else
  local tmp=$Z4M/tmp/zcompdump.$sysparams[pid]
  zf_rm -f -- $dump $dump.zwc $tmp $tmp.2
  -z4m-compinit-impl -C -d $tmp
  { print -rn -- $real_sig; <$tmp } >$tmp.2
  zf_rm -f -- $tmp
  zf_mv -- $tmp.2 $dump
  -z4m-compile $dump
fi

# Replay compdef calls.
local args
for args in $_z4m_compdef; do
  compdef "${(@0)args}"
done
unset _z4m_compdef

# HashiCorp tools have built-in completion support
local cmd
for cmd in terraform vault packer; do
  if [[ -v commands[$cmd] && ! -v _comps[$cmd] ]]; then
    complete -o nospace -C =$cmd $cmd
  fi
done

if [[ -v commands[aws_completer] && ! -v _comps[aws] ]]; then
  complete -C =aws_completer aws
fi

if [[ -v commands[gcloud] && ! -v _comps[gcloud] ]]; then
  local dirs=(
    ${HOMEBREW_PREFIX:+$HOMEBREW_PREFIX/share/google-cloud-sdk}
    ~/google-cloud-sdk
    /usr/share/google-cloud-sdk
    /snap/google-cloud-sdk/current
    /snap/google-cloud-cli/current
    /usr/lib/google-cloud-sdk
    /usr/lib64/google-cloud-sdk
    /opt/google-cloud-sdk
    /opt/local/libexec/google-cloud-sdk
  )
  source -- $^dirs/completion.zsh.inc(-.Ne'<[[ -r ${REPLY:a} ]]>') /dev/null
fi

# Carapace completion engine integration (Carapace-first strategy)
# Register Carapace for all supported commands except exclusion list
if [[ -n $_z4m_carapace_bin && -x $_z4m_carapace_bin ]]; then
  # Commands with built-in completion support (don't override with carapace)
  local -a native_handled=(terraform vault packer aws gcloud)

  for cmd in $_z4m_carapace_supported_commands; do
    # Skip if command not installed
    [[ -v commands[$cmd] ]] || continue
    # Skip if in exclusion list (git, ssh by default)
    (( ${_z4m_carapace_exclude[(Ie)$cmd]} )) && continue
    # Skip if already handled by native completers
    (( ${native_handled[(Ie)$cmd]} )) && continue
    # Register Carapace completion
    compdef -- -z4m-complete-carapace $cmd
  done
fi
