#!/usr/bin/env zsh

emulate -L zsh -o typeset_silent -o pipe_fail -o extended_glob \
    -o prompt_percent -o no_prompt_subst -o no_prompt_bang -o no_bg_nice -o no_aliases

if (( ARGC )); then
  local direnv=$1
else
  local direnv=${commands[direnv]-}
  if [[ -z $direnv ]]; then
    unset _z4m_direnv_sig
    return 1
  fi
fi

local sig
local envrc=(./(../)#.envrc(NY1:a))
if (( $#envrc )); then
  local -a deps=(
    ${XDG_DATA_HOME:-~/.local/share}/direnv/allow
    ${XDG_CONFIG_HOME:-~/.config}/{direnv.toml,config.toml})
  local -a stat
  local files=($^deps(N))
  if zstat -A stat +mtime -- $envrc $files 2>/dev/null; then
    local sig=$envrc$'\0'${(pj:\0:)stat}
  else
    local sig=stat-error
  fi
elif [[ ! -v DIRENV_WATCHES ]]; then
  typeset -g _z4m_direnv_sig=none
  return
else
  local sig=none
fi

[[ $sig == ${_z4m_direnv_sig-} ]] && return

unset _z4m_direnv_sig

# Timeout for direnv export (default 10 seconds)
local -i timeout
zstyle -s ':z4m:direnv' timeout timeout || timeout=10

local data
local -i timed_out=0

# Set up INT trap to show helpful message on Ctrl-C
local _z4m_direnv_envrc=${envrc[1]:-$PWD/.envrc}
trap '
  print -Pru2 ""
  print -Pru2 "%F{yellow}z4m%f: direnv interrupted by Ctrl-C"
  print -Pru2 "%F{yellow}z4m%f: .envrc: %F{cyan}${_z4m_direnv_envrc}%f"
  print -Pru2 "%F{yellow}z4m%f: to disable direnv for this directory: %F{green}direnv deny%f"
  typeset -g _z4m_direnv_sig=interrupted
  return 130
' INT

# Run direnv with timeout if timeout/gtimeout command is available
local timeout_cmd=
if command -v timeout &>/dev/null; then
  timeout_cmd=timeout
elif command -v gtimeout &>/dev/null; then
  timeout_cmd=gtimeout
fi

if [[ -n $timeout_cmd ]]; then
  # Use timeout command, capture stdout and stderr separately
  local tmpfile=${TMPDIR:-/tmp}/z4m-direnv-$$
  local errfile=${TMPDIR:-/tmp}/z4m-direnv-err-$$
  local -i ret
  $timeout_cmd ${timeout}s $direnv export zsh >$tmpfile 2>$errfile
  ret=$?

  if (( ret == 124 )); then
    timed_out=1
    zf_rm -f $tmpfile $errfile 2>/dev/null
  else
    local out=$(<$tmpfile)
    local err=$(<$errfile)
    zf_rm -f $tmpfile $errfile 2>/dev/null
    # Format: err + out + out_len(18 digits) + success(1 digit)
    data="${err}$(builtin printf '%s%18d%d' "$out" $#out $(( ret == 0 )))"
  fi
else
  # No timeout support, run directly (original behavior)
  data=$(
    local out ret
    out=$($direnv export zsh) 2>&1
    ret=$?
    builtin printf '%s%18d%d' "$out" $#out $(( ret == 0 ))
  ) || { trap - INT; return; }
fi

trap - INT

if (( timed_out )); then
  print -Pru2 "%F{yellow}z4m%f: direnv timed out after ${timeout}s"
  print -Pru2 "%F{yellow}z4m%f: .envrc: %F{cyan}${envrc[1]:-$PWD/.envrc}%f"
  print -Pru2 "%F{yellow}z4m%f: check your .envrc for slow commands"
  print -Pru2 "%F{yellow}z4m%f: to increase timeout: %F{green}zstyle ':z4m:direnv' timeout 30%f"
  print -Pru2 "%F{yellow}z4m%f: to disable for this dir: %F{green}direnv deny%f"
  typeset -g _z4m_direnv_sig=timeout
  return 1
fi

[[ -n $data ]] || return

local -i success=$data[-1]
local -i out_len=$data[-19,-2]
local out=$data[-out_len-19,-20]
local err=${data[1,-out_len-20]%%$'\n'#}

if [[ -n $err ]]; then
  local ctx=:z4m:direnv:
  (( success )) && ctx+='success' || ctx+='error'
  # Default: show error notifications, hide success notifications (less noise)
  local should_notify
  if (( success )); then
    zstyle -t $ctx notify && should_notify=1  # success: default off
  else
    zstyle -T $ctx notify && should_notify=1  # error: default on
  fi
  if [[ -n $should_notify ]]; then
    if builtin zle; then
      typeset -g _p9k__raw_msg=${err//\%/%%}$'\n'
    else
      print -ru2 -- $err
    fi
  fi
fi

emulate -L zsh
if [[ ! -v __p9k_trapped ]]; then
  local -i __p9k_trapped
  builtin trap : INT
  builtin trap "builtin trap ${(q)__p9k_trapint:--} INT" EXIT
fi
builtin eval -- $out
typeset -g _z4m_direnv_sig=$sig
